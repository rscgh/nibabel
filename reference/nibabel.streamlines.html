
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Neuroimaging in Python &#8212; NiBabel 3.2.0 documentation</title>
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="trackvis" href="nibabel.trackvis.html" />
    <link rel="prev" title="parrec" href="nibabel.parrec.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div class="row" style="display: flex; flex-direction: row; flex-wrap: wrap; width: 100%;">
  <div class="column" style="background-color: white; display: flex; flex-direction: column; flex: 0 0 140px; padding-left: 2px; padding-bottom:2px; padding-top:2px;">
    <img src="../_static/nibabel-logo.svg" class="logo" alt="Logo" width="130px"/>
  </div>
  <div class="column" style="background-color: white; text-align: left; padding-left: 10px; padding-bottom:50px; padding-top:20px; background-repeat: no-repeat; display: flex; flex-direction: column; flex-basis: 100%; flex: 1;">
    <h1>NiBabel</h1>
    <h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.trackvis.html" title="trackvis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.parrec.html" title="parrec"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines</span></code></a><ul>
<li><a class="reference internal" href="#module-nibabel.streamlines.array_sequence">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.array_sequence</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.header">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.header</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.tck">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tck</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.tractogram">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tractogram</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.tractogram_file">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tractogram_file</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.trk">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.trk</span></code></a></li>
<li><a class="reference internal" href="#module-nibabel.streamlines.utils">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.utils</span></code></a><ul>
<li><a class="reference internal" href="#detect-format">detect_format</a></li>
<li><a class="reference internal" href="#is-supported">is_supported</a></li>
<li><a class="reference internal" href="#load">load</a></li>
<li><a class="reference internal" href="#save">save</a></li>
<li><a class="reference internal" href="#arraysequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a></li>
<li><a class="reference internal" href="#concatenate">concatenate</a></li>
<li><a class="reference internal" href="#create-arraysequences-from-generator">create_arraysequences_from_generator</a></li>
<li><a class="reference internal" href="#is-array-sequence">is_array_sequence</a></li>
<li><a class="reference internal" href="#is-ndarray-of-int-or-bool">is_ndarray_of_int_or_bool</a></li>
<li><a class="reference internal" href="#field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a></li>
<li><a class="reference internal" href="#tckfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TckFile</span></code></a></li>
<li><a class="reference internal" href="#lazydict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a></li>
<li><a class="reference internal" href="#lazytractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a></li>
<li><a class="reference internal" href="#perarraydict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a></li>
<li><a class="reference internal" href="#perarraysequencedict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArraySequenceDict</span></code></a></li>
<li><a class="reference internal" href="#sliceabledatadict"><code class="xref py py-class docutils literal notranslate"><span class="pre">SliceableDataDict</span></code></a></li>
<li><a class="reference internal" href="#tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a></li>
<li><a class="reference internal" href="#tractogramitem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a></li>
<li><a class="reference internal" href="#is-data-dict">is_data_dict</a></li>
<li><a class="reference internal" href="#is-lazy-dict">is_lazy_dict</a></li>
<li><a class="reference internal" href="#dataerror"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataError</span></code></a></li>
<li><a class="reference internal" href="#datawarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataWarning</span></code></a></li>
<li><a class="reference internal" href="#extensionwarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionWarning</span></code></a></li>
<li><a class="reference internal" href="#headererror"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderError</span></code></a></li>
<li><a class="reference internal" href="#headerwarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderWarning</span></code></a></li>
<li><a class="reference internal" href="#tractogramfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code></a></li>
<li><a class="reference internal" href="#abstractclassmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">abstractclassmethod</span></code></a></li>
<li><a class="reference internal" href="#trkfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrkFile</span></code></a></li>
<li><a class="reference internal" href="#decode-value-from-name">decode_value_from_name</a></li>
<li><a class="reference internal" href="#encode-value-in-name">encode_value_in_name</a></li>
<li><a class="reference internal" href="#get-affine-rasmm-to-trackvis">get_affine_rasmm_to_trackvis</a></li>
<li><a class="reference internal" href="#get-affine-trackvis-to-rasmm">get_affine_trackvis_to_rasmm</a></li>
<li><a class="reference internal" href="#get-affine-from-reference">get_affine_from_reference</a></li>
<li><a class="reference internal" href="#peek-next">peek_next</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.parrec.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parrec</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.trackvis.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trackvis</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.streamlines.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.streamlines">
<span id="streamlines"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines</span></code><a class="headerlink" href="#module-nibabel.streamlines" title="Permalink to this headline">¶</a></h1>
<p>Multiformat-capable streamline format read / write interface</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.detect_format" title="nibabel.streamlines.detect_format"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_format</span></code></a>(fileobj)</p></td>
<td><p>Returns the StreamlinesFile object guessed from the file-like object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.is_supported" title="nibabel.streamlines.is_supported"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_supported</span></code></a>(fileobj)</p></td>
<td><p>Checks if the file-like object if supported by NiBabel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.load" title="nibabel.streamlines.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(fileobj[, lazy_load])</p></td>
<td><p>Loads streamlines in <em>RAS+</em> and <em>mm</em> space from a file-like object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.save" title="nibabel.streamlines.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(tractogram, filename, \*\*kwargs)</p></td>
<td><p>Saves a tractogram to a file.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="module-nibabel.streamlines.array_sequence">
<span id="module-streamlines-array-sequence"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.array_sequence</span></code><a class="headerlink" href="#module-nibabel.streamlines.array_sequence" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ArraySequence</span></code></a>([iterable, buffer_size])</p></td>
<td><p>Sequence of ndarrays having variable first dimension sizes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.array_sequence.concatenate" title="nibabel.streamlines.array_sequence.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a>(seqs, axis)</p></td>
<td><p>Concatenates multiple <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> objects along an axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.array_sequence.create_arraysequences_from_generator" title="nibabel.streamlines.array_sequence.create_arraysequences_from_generator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_arraysequences_from_generator</span></code></a>(gen, n)</p></td>
<td><p>Creates <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> objects from a generator yielding tuples</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.array_sequence.is_array_sequence" title="nibabel.streamlines.array_sequence.is_array_sequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_array_sequence</span></code></a>(obj)</p></td>
<td><p>Return True if <cite>obj</cite> is an array sequence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool" title="nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_ndarray_of_int_or_bool</span></code></a>(obj)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.header">
<span id="module-streamlines-header"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.header</span></code><a class="headerlink" href="#module-nibabel.streamlines.header" title="Permalink to this headline">¶</a></h2>
<p>Field class defining common header fields in tractogram files</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.header.Field" title="nibabel.streamlines.header.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a></p></td>
<td><p>Header fields common to multiple streamline file formats.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.tck">
<span id="module-streamlines-tck"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tck</span></code><a class="headerlink" href="#module-nibabel.streamlines.tck" title="Permalink to this headline">¶</a></h2>
<p>Read / write access to TCK streamlines format.</p>
<p>TCK format is defined at
<a class="reference external" href="http://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html?highlight=format#tracks-file-format-tck">http://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html?highlight=format#tracks-file-format-tck</a></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tck.TckFile" title="nibabel.streamlines.tck.TckFile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TckFile</span></code></a>(tractogram[, header])</p></td>
<td><p>Convenience class to encapsulate TCK file format.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.tractogram">
<span id="module-streamlines-tractogram"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tractogram</span></code><a class="headerlink" href="#module-nibabel.streamlines.tractogram" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyDict</span></code></a>(*args, **kwargs)</p></td>
<td><p>Dictionary of generator functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a>([streamlines, …])</p></td>
<td><p>Lazy container for streamlines and their data information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a>([n_rows])</p></td>
<td><p>Dictionary for which key access can do slicing on the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PerArraySequenceDict</span></code></a>([n_rows])</p></td>
<td><p>Dictionary for which key access can do slicing on the values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SliceableDataDict</span></code></a>(*args, **kwargs)</p></td>
<td><p>Dictionary for which key access can do slicing on the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tractogram</span></code></a>([streamlines, …])</p></td>
<td><p>Container for streamlines and their data information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TractogramItem</span></code></a>(streamline, …)</p></td>
<td><p>Class containing information about one streamline.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.is_data_dict" title="nibabel.streamlines.tractogram.is_data_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_data_dict</span></code></a>(obj)</p></td>
<td><p>True if <cite>obj</cite> seems to implement the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataDict</span></code> API</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram.is_lazy_dict" title="nibabel.streamlines.tractogram.is_lazy_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_lazy_dict</span></code></a>(obj)</p></td>
<td><p>True if <cite>obj</cite> seems to implement the <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a> API</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.tractogram_file">
<span id="module-streamlines-tractogram-file"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.tractogram_file</span></code><a class="headerlink" href="#module-nibabel.streamlines.tractogram_file" title="Permalink to this headline">¶</a></h2>
<p>Define abstract interface for Tractogram file classes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataError" title="nibabel.streamlines.tractogram_file.DataError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataError</span></code></a></p></td>
<td><p>Raised when data is missing or inconsistent in a tractogram file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataWarning" title="nibabel.streamlines.tractogram_file.DataWarning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataWarning</span></code></a></p></td>
<td><p>Base class for warnings about tractogram file data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="nibabel.streamlines.tractogram_file.ExtensionWarning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtensionWarning</span></code></a></p></td>
<td><p>Base class for warnings about tractogram file extension.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderError" title="nibabel.streamlines.tractogram_file.HeaderError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HeaderError</span></code></a></p></td>
<td><p>Raised when a tractogram file header contains invalid information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="nibabel.streamlines.tractogram_file.HeaderWarning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HeaderWarning</span></code></a></p></td>
<td><p>Base class for warnings about tractogram file header.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TractogramFile</span></code></a>(tractogram[, header])</p></td>
<td><p>Convenience class to encapsulate tractogram file format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="nibabel.streamlines.tractogram_file.abstractclassmethod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abstractclassmethod</span></code></a>(callable)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.trk">
<span id="module-streamlines-trk"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.trk</span></code><a class="headerlink" href="#module-nibabel.streamlines.trk" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TrkFile</span></code></a>(tractogram[, header])</p></td>
<td><p>Convenience class to encapsulate TRK file format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.trk.decode_value_from_name" title="nibabel.streamlines.trk.decode_value_from_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decode_value_from_name</span></code></a>(encoded_name)</p></td>
<td><p>Decodes a value that has been encoded in the last bytes of a string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.trk.encode_value_in_name" title="nibabel.streamlines.trk.encode_value_in_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encode_value_in_name</span></code></a>(value, name[, max_name_len])</p></td>
<td><p>Return <cite>name</cite> as fixed-length string, appending <cite>value</cite> as string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.trk.get_affine_rasmm_to_trackvis" title="nibabel.streamlines.trk.get_affine_rasmm_to_trackvis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_rasmm_to_trackvis</span></code></a>(header)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.trk.get_affine_trackvis_to_rasmm" title="nibabel.streamlines.trk.get_affine_trackvis_to_rasmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_trackvis_to_rasmm</span></code></a>(header)</p></td>
<td><p>Get affine mapping trackvis voxelmm space to RAS+ mm space</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-nibabel.streamlines.utils">
<span id="module-streamlines-utils"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlines.utils</span></code><a class="headerlink" href="#module-nibabel.streamlines.utils" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.streamlines.utils.get_affine_from_reference" title="nibabel.streamlines.utils.get_affine_from_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_from_reference</span></code></a>(ref)</p></td>
<td><p>Returns the affine defining the reference space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.streamlines.utils.peek_next" title="nibabel.streamlines.utils.peek_next"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peek_next</span></code></a>(iterable)</p></td>
<td><p>Peek next element of iterable.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="detect-format">
<h3>detect_format<a class="headerlink" href="#detect-format" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.detect_format">
<code class="sig-prename descclassname">nibabel.streamlines.</code><code class="sig-name descname">detect_format</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.detect_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the StreamlinesFile object guessed from the file-like object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object pointing
to a tractogram file (and ready to read from the beginning of the
header)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tractogram_file</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> class</span></dt><dd><p>The class type guessed from the content of <cite>fileobj</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="is-supported">
<h3>is_supported<a class="headerlink" href="#is-supported" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.is_supported">
<code class="sig-prename descclassname">nibabel.streamlines.</code><code class="sig-name descname">is_supported</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.is_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the file-like object if supported by NiBabel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object pointing
to a streamlines file (and ready to read from the beginning of the
header)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_supported</strong><span class="classifier">boolean</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="load">
<h3>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.load">
<code class="sig-prename descclassname">nibabel.streamlines.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines in <em>RAS+</em> and <em>mm</em> space from a file-like object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the beginning
of the streamlines file’s header).</p>
</dd>
<dt><strong>lazy_load</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, load streamlines in a lazy manner i.e. they will not be kept
in memory and only be loaded when needed.
Otherwise, load all streamlines in memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tractogram_file</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> object</span></dt><dd><p>Returns an instance of a <code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> containing data and
metadata of the tractogram loaded from <cite>fileobj</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The streamline coordinate (0,0,0) refers to the center of the voxel.</p>
</dd></dl>

</div>
<div class="section" id="save">
<h3>save<a class="headerlink" href="#save" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.save">
<code class="sig-prename descclassname">nibabel.streamlines.</code><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">tractogram</em>, <em class="sig-param">filename</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a tractogram to a file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object or <code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> object</span></dt><dd><p>If <code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object, the file format will be guessed from
<cite>filename</cite> and a <code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> object will be created using
provided keyword arguments.
If <code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> object, the file format is known and will
be used to save its content to <cite>filename</cite>.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of the file where the tractogram will be saved.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Keyword arguments passed to <code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code> constructor.
Should not be specified if <cite>tractogram</cite> is already an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="arraysequence">
<h3><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a><a class="headerlink" href="#arraysequence" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.array_sequence.ArraySequence">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.array_sequence.</code><code class="sig-name descname">ArraySequence</code><span class="sig-paren">(</span><em class="sig-param">iterable=None</em>, <em class="sig-param">buffer_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Sequence of ndarrays having variable first dimension sizes.</p>
<p>This is a container that can store multiple ndarrays where each ndarray
might have a different first dimension size but a <em>common</em> size for the
remaining dimensions.</p>
<p>More generally, an instance of <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> of length <span class="math notranslate nohighlight">\(N\)</span> is
composed of <span class="math notranslate nohighlight">\(N\)</span> ndarrays of shape <span class="math notranslate nohighlight">\((d_1, d_2, ... d_D)\)</span> where <span class="math notranslate nohighlight">\(d_1\)</span>
can vary in length between arrays but <span class="math notranslate nohighlight">\((d_2, ..., d_D)\)</span> have to be the
same for every ndarray.</p>
<p>Initialize array sequence instance</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iterable</strong><span class="classifier">None or iterable or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a>, optional</span></dt><dd><p>If None, create an empty <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object.
If iterable, create a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object initialized
from array-like objects yielded by the iterable.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a>, create a view (no memory is allocated).
For an actual copy use <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="nibabel.streamlines.array_sequence.ArraySequence.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> instead.</p>
</dd>
<dt><strong>buffer_size</strong><span class="classifier">float, optional</span></dt><dd><p>Size (in Mb) for memory allocation when <cite>iterable</cite> is a generator.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">iterable=None</em>, <em class="sig-param">buffer_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize array sequence instance</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iterable</strong><span class="classifier">None or iterable or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a>, optional</span></dt><dd><p>If None, create an empty <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object.
If iterable, create a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object initialized
from array-like objects yielded by the iterable.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a>, create a view (no memory is allocated).
For an actual copy use <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="nibabel.streamlines.array_sequence.ArraySequence.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> instead.</p>
</dd>
<dt><strong>buffer_size</strong><span class="classifier">float, optional</span></dt><dd><p>Size (in Mb) for memory allocation when <cite>iterable</cite> is a generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">element</em>, <em class="sig-param">cache_build=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends <cite>element</cite> to this array sequence.</p>
<p>Append can be a lot faster if it knows that it is appending several
elements instead of a single element.  In that case it can cache the
parameters it uses between append operations, in a “build cache”.  To
tell append to do this, use <code class="docutils literal notranslate"><span class="pre">cache_build=True</span></code>.  If you use
<code class="docutils literal notranslate"><span class="pre">cache_build=True</span></code>, you need to finalize the append operations with
<a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.finalize_append" title="nibabel.streamlines.array_sequence.ArraySequence.finalize_append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finalize_append()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>element</strong><span class="classifier">ndarray</span></dt><dd><p>Element to append. The shape must match already inserted elements
shape except for the first dimension.</p>
</dd>
<dt><strong>cache_build</strong><span class="classifier">{False, True}</span></dt><dd><p>Whether to save the build cache from this append routine.  If True,
append can assume it is the only player updating <cite>self</cite>, and the
caller must finalize <cite>self</cite> after all append operations, with
<code class="docutils literal notranslate"><span class="pre">self.finalize_append()</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If you need to add multiple elements you should consider
<cite>ArraySequence.extend</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.common_shape">
<em class="property">property </em><code class="sig-name descname">common_shape</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.common_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Matching shape of the elements in this array sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a copy of this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>seq_copy</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> instance</span></dt><dd><p>Copy of <cite>self</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We do not simply deepcopy this object because we have a chance to use
less memory. For example, if the array sequence being copied is the
result of a slicing operation on an array sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Elements in this array sequence.</p>
<p>‘ArraySequence.data’ property is deprecated.
Please use the ‘ArraySequence.get_data()’ method instead</p>
<ul class="simple">
<li><p>deprecated from version: 3.0</p></li>
<li><p>Will raise &lt;class ‘nibabel.deprecator.ExpiredDeprecationError’&gt; as of version: 4.0</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">elements</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends all <cite>elements</cite> to this array sequence.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>elements</strong><span class="classifier">iterable of ndarrays or <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object</span></dt><dd><p>If iterable of ndarrays, each ndarray will be concatenated along
the first dimension then appended to the data of this
ArraySequence.
If <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object, its data are simply appended to
the data of this ArraySequence.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The shape of the elements to be added must match the one of the data of
this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> except for the first dimension.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.finalize_append">
<code class="sig-name descname">finalize_append</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.finalize_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize process of appending several elements to <cite>self</cite></p>
<p><a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="nibabel.streamlines.array_sequence.ArraySequence.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> can be a lot faster if it knows that it is appending
several elements instead of a single element.  To tell the append
method this is the case, use <code class="docutils literal notranslate"><span class="pre">cache_build=True</span></code>.  This method
finalizes the series of append operations after a call to
<a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence.append" title="nibabel.streamlines.array_sequence.ArraySequence.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">cache_build=True</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.get_data">
<code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>copy</em> of the elements in this array sequence.</p>
<p class="rubric">Notes</p>
<p>To modify the data on this array sequence, one can use
in-place mathematical operators (e.g., <cite>seq += …</cite>) or the use
assignment operator (i.e, <cite>seq[…] = value</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.is_array_sequence">
<em class="property">property </em><code class="sig-name descname">is_array_sequence</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.is_array_sequence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object from a .npz file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves this <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object to a .npz file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.shrink_data">
<code class="sig-name descname">shrink_data</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.shrink_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.array_sequence.ArraySequence.total_nb_rows">
<em class="property">property </em><code class="sig-name descname">total_nb_rows</code><a class="headerlink" href="#nibabel.streamlines.array_sequence.ArraySequence.total_nb_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of rows in this array sequence.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="concatenate">
<h3>concatenate<a class="headerlink" href="#concatenate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.concatenate">
<code class="sig-prename descclassname">nibabel.streamlines.array_sequence.</code><code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param">seqs</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates multiple <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> objects along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seqs: iterable of :class:`ArraySequence` objects</strong></dt><dd><p>Sequences to concatenate.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis along which the sequences will be concatenated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>new_seq: <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object</dt><dd><p>New <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> object which is the result of
concatenating multiple sequences along the given axis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="create-arraysequences-from-generator">
<h3>create_arraysequences_from_generator<a class="headerlink" href="#create-arraysequences-from-generator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.create_arraysequences_from_generator">
<code class="sig-prename descclassname">nibabel.streamlines.array_sequence.</code><code class="sig-name descname">create_arraysequences_from_generator</code><span class="sig-paren">(</span><em class="sig-param">gen</em>, <em class="sig-param">n</em>, <em class="sig-param">buffer_sizes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.create_arraysequences_from_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates <a class="reference internal" href="#nibabel.streamlines.array_sequence.ArraySequence" title="nibabel.streamlines.array_sequence.ArraySequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code></a> objects from a generator yielding tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gen</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding a size <cite>n</cite> tuple containing the values to put in the
array sequences.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of <code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequences</span></code> object to create.</p>
</dd>
<dt><strong>buffer_sizes</strong><span class="classifier">list of float, optional</span></dt><dd><p>Sizes (in Mb) for each ArraySequence’s buffer.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="is-array-sequence">
<h3>is_array_sequence<a class="headerlink" href="#is-array-sequence" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.is_array_sequence">
<code class="sig-prename descclassname">nibabel.streamlines.array_sequence.</code><code class="sig-name descname">is_array_sequence</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.is_array_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if <cite>obj</cite> is an array sequence.</p>
</dd></dl>

</div>
<div class="section" id="is-ndarray-of-int-or-bool">
<h3>is_ndarray_of_int_or_bool<a class="headerlink" href="#is-ndarray-of-int-or-bool" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool">
<code class="sig-prename descclassname">nibabel.streamlines.array_sequence.</code><code class="sig-name descname">is_ndarray_of_int_or_bool</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.array_sequence.is_ndarray_of_int_or_bool" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="field">
<h3><a class="reference internal" href="#nibabel.streamlines.header.Field" title="nibabel.streamlines.header.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a><a class="headerlink" href="#field" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.header.Field">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.header.</code><code class="sig-name descname">Field</code><a class="headerlink" href="#nibabel.streamlines.header.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Header fields common to multiple streamline file formats.</p>
<p>In IPython, use <cite>nibabel.streamlines.Field??</cite> to list them.</p>
<dl class="method">
<dt id="nibabel.streamlines.header.Field.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.header.Field.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.DIMENSIONS">
<code class="sig-name descname">DIMENSIONS</code><em class="property"> = 'dimensions'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.DIMENSIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.ENDIANNESS">
<code class="sig-name descname">ENDIANNESS</code><em class="property"> = 'endianness'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.ENDIANNESS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.MAGIC_NUMBER">
<code class="sig-name descname">MAGIC_NUMBER</code><em class="property"> = 'magic_number'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.MAGIC_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.METHOD">
<code class="sig-name descname">METHOD</code><em class="property"> = 'method'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.METHOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_POINTS">
<code class="sig-name descname">NB_POINTS</code><em class="property"> = 'nb_points'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_POINTS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_PROPERTIES_PER_STREAMLINE">
<code class="sig-name descname">NB_PROPERTIES_PER_STREAMLINE</code><em class="property"> = 'nb_properties_per_streamline'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_PROPERTIES_PER_STREAMLINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_SCALARS_PER_POINT">
<code class="sig-name descname">NB_SCALARS_PER_POINT</code><em class="property"> = 'nb_scalars_per_point'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_SCALARS_PER_POINT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.NB_STREAMLINES">
<code class="sig-name descname">NB_STREAMLINES</code><em class="property"> = 'nb_streamlines'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.NB_STREAMLINES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.ORIGIN">
<code class="sig-name descname">ORIGIN</code><em class="property"> = 'origin'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.ORIGIN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.STEP_SIZE">
<code class="sig-name descname">STEP_SIZE</code><em class="property"> = 'step_size'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.STEP_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_ORDER">
<code class="sig-name descname">VOXEL_ORDER</code><em class="property"> = 'voxel_order'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_ORDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_SIZES">
<code class="sig-name descname">VOXEL_SIZES</code><em class="property"> = 'voxel_sizes'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_SIZES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.header.Field.VOXEL_TO_RASMM">
<code class="sig-name descname">VOXEL_TO_RASMM</code><em class="property"> = 'voxel_to_rasmm'</em><a class="headerlink" href="#nibabel.streamlines.header.Field.VOXEL_TO_RASMM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="tckfile">
<h3><a class="reference internal" href="#nibabel.streamlines.tck.TckFile" title="nibabel.streamlines.tck.TckFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TckFile</span></code></a><a class="headerlink" href="#tckfile" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tck.TckFile">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tck.</code><code class="sig-name descname">TckFile</code><span class="sig-paren">(</span><em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.tractogram_file.TractogramFile</span></code></a></p>
<p>Convenience class to encapsulate TCK file format.</p>
<p class="rubric">Notes</p>
<p>MRtrix (so its file format: TCK) considers streamlines coordinates
to be in world space (RAS+ and mm space). MRtrix refers to that space
as the “real” or “scanner” space <a class="footnote-reference brackets" href="#id3" id="id1">1</a>.</p>
<p>Moreover, when streamlines are mapped back to voxel space <a class="footnote-reference brackets" href="#id4" id="id2">2</a>, a
streamline point located at an integer coordinate (i,j,k) is considered
to be at the center of the corresponding voxel. This is in contrast with
TRK’s internal convention where it would have referred to a corner.</p>
<p>NiBabel’s streamlines internal representation follows the same
convention as MRtrix.</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.nitrc.org/pipermail/mrtrix-discussion/2014-January/000859.html">http://www.nitrc.org/pipermail/mrtrix-discussion/2014-January/000859.html</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference external" href="http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space">http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space</a></p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object</span></dt><dd><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.tck.TckFile" title="nibabel.streamlines.tck.TckFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TckFile</span></code></a>.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or dict, optional</span></dt><dd><p>Metadata associated to this tractogram file. If None, make
default empty header.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em> and <em>mm</em>
space. It is also assumed that when streamlines are mapped back to
voxel space, a streamline point located at an integer coordinate
(i,j,k) is considered to be at the center of the corresponding voxel.
This is in contrast with TRK’s internal convention where it would
have referred to a corner.</p>
<dl class="method">
<dt id="nibabel.streamlines.tck.TckFile.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object</span></dt><dd><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.tck.TckFile" title="nibabel.streamlines.tck.TckFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TckFile</span></code></a>.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or dict, optional</span></dt><dd><p>Metadata associated to this tractogram file. If None, make
default empty header.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em> and <em>mm</em>
space. It is also assumed that when streamlines are mapped back to
voxel space, a streamline point located at an integer coordinate
(i,j,k) is considered to be at the center of the corresponding voxel.
This is in contrast with TRK’s internal convention where it would
have referred to a corner.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tck.TckFile.EOF_DELIMITER">
<code class="sig-name descname">EOF_DELIMITER</code><em class="property"> = array([[inf, inf, inf]], dtype=float32)</em><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.EOF_DELIMITER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tck.TckFile.FIBER_DELIMITER">
<code class="sig-name descname">FIBER_DELIMITER</code><em class="property"> = array([[nan, nan, nan]], dtype=float32)</em><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.FIBER_DELIMITER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tck.TckFile.MAGIC_NUMBER">
<code class="sig-name descname">MAGIC_NUMBER</code><em class="property"> = 'mrtrix tracks'</em><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.MAGIC_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tck.TckFile.SUPPORTS_DATA_PER_POINT">
<code class="sig-name descname">SUPPORTS_DATA_PER_POINT</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.SUPPORTS_DATA_PER_POINT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.tck.TckFile.SUPPORTS_DATA_PER_STREAMLINE">
<code class="sig-name descname">SUPPORTS_DATA_PER_STREAMLINE</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.SUPPORTS_DATA_PER_STREAMLINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tck.TckFile.create_empty_header">
<em class="property">classmethod </em><code class="sig-name descname">create_empty_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.create_empty_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty compliant TCK header as dict</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tck.TckFile.is_correct_format">
<em class="property">classmethod </em><code class="sig-name descname">is_correct_format</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.is_correct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the file is in TCK format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object in
binary mode pointing to TCK file (and ready to read from the
beginning of the TCK header). Note that calling this function
does not change the file position.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_correct_format</strong><span class="classifier">{True, False}</span></dt><dd><p>Returns True if <cite>fileobj</cite> is compatible with TCK format,
otherwise returns False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tck.TckFile.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines from a filename or file-like object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object in
binary mode pointing to TCK file (and ready to read from the
beginning of the TCK header). Note that calling this function
does not change the file position.</p>
</dd>
<dt><strong>lazy_load</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, load streamlines in a lazy manner i.e. they will not be
kept in memory. Otherwise, load all streamlines in memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tck_file</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tck.TckFile" title="nibabel.streamlines.tck.TckFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TckFile</span></code></a> object</span></dt><dd><p>Returns an object containing tractogram data and header
information.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em> and <em>mm</em>
space. It is also assumed that when streamlines are mapped back to
voxel space, a streamline point located at an integer coordinate
(i,j,k) is considered to be at the center of the corresponding voxel.
This is in contrast with TRK’s internal convention where it would
have referred to a corner.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tck.TckFile.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tck.TckFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save tractogram to a filename or file-like object using TCK format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object in
binary mode pointing to TCK file (and ready to write from the
beginning of the TCK header data).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lazydict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a><a class="headerlink" href="#lazydict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.LazyDict">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">LazyDict</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></p>
<p>Dictionary of generator functions.</p>
<p>This container behaves like a dictionary but it makes sure its elements are
callable objects that it assumes are generator functions yielding values.
When getting the element associated with a given key, the element (i.e. a
generator function) is first called before being returned.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lazytractogram">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a><a class="headerlink" href="#lazytractogram" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.LazyTractogram">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">LazyTractogram</code><span class="sig-paren">(</span><em class="sig-param">streamlines=None</em>, <em class="sig-param">data_per_streamline=None</em>, <em class="sig-param">data_per_point=None</em>, <em class="sig-param">affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.tractogram.Tractogram</span></code></a></p>
<p>Lazy container for streamlines and their data information.</p>
<p>This container behaves lazily as it uses generator functions to manage
streamlines and their data information. This container is thus memory
friendly since it doesn’t require having all this data loaded in memory.</p>
<p>Streamlines of a tractogram can be in any coordinate system of your
choice as long as you provide the correct <cite>affine_to_rasmm</cite> matrix, at
construction time. When applied to streamlines coordinates, that
transformation matrix should bring the streamlines back to world space
(RAS+ and mm space) <a class="footnote-reference brackets" href="#id7" id="id5">3</a>.</p>
<p>Moreover, when streamlines are mapped back to voxel space <a class="footnote-reference brackets" href="#id8" id="id6">4</a>, a
streamline point located at an integer coordinate (i,j,k) is considered
to be at the center of the corresponding voxel. This is in contrast with
other conventions where it might have referred to a corner.</p>
<p class="rubric">Notes</p>
<p>LazyTractogram objects do not support indexing currently.
LazyTractogram objects are suited for operations that can be linearized
such as applying an affine transformation or converting streamlines from
one file format to another.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p><a class="reference external" href="http://nipy.org/nibabel/coordinate_systems.html#naming-reference-spaces">http://nipy.org/nibabel/coordinate_systems.html#naming-reference-spaces</a></p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p><a class="reference external" href="http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space">http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space</a></p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">generator function</span></dt><dd><p>Generator function yielding streamlines. Each streamline is an
ndarray of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier">instance of <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a></span></dt><dd><p>Dictionary where the items are (str, instantiated generator).
Each key represents a piece of information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside
every streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math notranslate nohighlight">\(P_i\)</span>,) where <span class="math notranslate nohighlight">\(P_i\)</span> is
the number of values to store for that particular piece of information
<span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a> object</span></dt><dd><p>Dictionary where the items are (str, instantiated generator).  Each key
represents a piece of information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every point
of every streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where
<span class="math notranslate nohighlight">\(N_t\)</span> is the number of points for a particular streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span>
is the number of values to store for that particular piece of
information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">generator function, optional</span></dt><dd><p>Generator function yielding streamlines. Each streamline is an
ndarray of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier">dict of generator functions, optional</span></dt><dd><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math notranslate nohighlight">\(P_i\)</span>,) where
<span class="math notranslate nohighlight">\(P_i\)</span> is the number of values to store for that particular
information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier">dict of generator functions, optional</span></dt><dd><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is a generator
function yielding that information via ndarrays of shape
(<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points for a particular
streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span> is the number of values to store for
that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>affine_to_rasmm</strong><span class="classifier">ndarray of shape (4, 4) or None, optional</span></dt><dd><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">streamlines=None</em>, <em class="sig-param">data_per_streamline=None</em>, <em class="sig-param">data_per_point=None</em>, <em class="sig-param">affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">generator function, optional</span></dt><dd><p>Generator function yielding streamlines. Each streamline is an
ndarray of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier">dict of generator functions, optional</span></dt><dd><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
streamline, and its associated value is a generator function
yielding that information via ndarrays of shape (<span class="math notranslate nohighlight">\(P_i\)</span>,) where
<span class="math notranslate nohighlight">\(P_i\)</span> is the number of values to store for that particular
information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier">dict of generator functions, optional</span></dt><dd><p>Dictionary where the items are (str, generator function).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is a generator
function yielding that information via ndarrays of shape
(<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points for a particular
streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span> is the number of values to store for
that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>affine_to_rasmm</strong><span class="classifier">ndarray of shape (4, 4) or None, optional</span></dt><dd><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.apply_affine">
<code class="sig-name descname">apply_affine</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">lazy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an affine transformation to the streamlines.</p>
<p>The transformation given by the <cite>affine</cite> matrix is applied after any
other pending transformations to the streamline points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">2D array (4,4)</span></dt><dd><p>Transformation matrix that will be applied on each streamline.</p>
</dd>
<dt><strong>lazy</strong><span class="classifier">True, optional</span></dt><dd><p>Should always be True for <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object. Doing
otherwise will raise a ValueError.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>lazy_tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>A copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> instance but with a
transformation to be applied on the streamlines.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data_per_point">
<em class="property">property </em><code class="sig-name descname">data_per_point</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data_per_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.data_per_streamline">
<em class="property">property </em><code class="sig-name descname">data_per_streamline</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.data_per_streamline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends the data of another <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a>.</p>
<p>Data that will be appended includes the streamlines and the content
of both dictionaries <cite>data_per_streamline</cite> and <cite>data_per_point</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object</span></dt><dd><p>Its data will be appended to the data of this tractogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The entries in both dictionaries <cite>self.data_per_streamline</cite> and
<cite>self.data_per_point</cite> must match respectively those contained in
the other tractogram.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.from_data_func">
<em class="property">classmethod </em><code class="sig-name descname">from_data_func</code><span class="sig-paren">(</span><em class="sig-param">data_func</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.from_data_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an instance from a generator function.</p>
<p>The generator function must yield <a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a> objects.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data_func</strong><span class="classifier">generator function yielding <a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a> objects</span></dt><dd><p>Generator function that whenever is called starts yielding
<a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a> objects that will be used to instantiate a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>lazy_tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>New lazy tractogram.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.from_tractogram">
<em class="property">classmethod </em><code class="sig-name descname">from_tractogram</code><span class="sig-paren">(</span><em class="sig-param">tractogram</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.from_tractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object from a <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractgogram</span></code> object</span></dt><dd><p>Tractogram from which to create a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>lazy_tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>New lazy tractogram.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.streamlines">
<em class="property">property </em><code class="sig-name descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.LazyTractogram.to_world">
<code class="sig-name descname">to_world</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">lazy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.LazyTractogram.to_world" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings the streamlines to world space (i.e. RAS+ and mm).</p>
<p>The transformation is applied after any other pending transformations
to the streamline points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lazy</strong><span class="classifier">True, optional</span></dt><dd><p>Should always be True for <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object. Doing
otherwise will raise a ValueError.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>lazy_tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>A copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> instance but with a
transformation to be applied on the streamlines.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="perarraydict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a><a class="headerlink" href="#perarraydict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.PerArrayDict">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">PerArrayDict</code><span class="sig-paren">(</span><em class="sig-param">n_rows=0</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArrayDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.tractogram.SliceableDataDict</span></code></a></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values. The elements must also be ndarrays.</p>
<p>In addition, it makes sure the amount of data contained in those ndarrays
matches the number of streamlines given at the instantiation of this
instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_rows</strong><span class="classifier">None or int, optional</span></dt><dd><p>Number of rows per value in each key, value pair or None for not
specified.</p>
</dd>
<dt><strong>*args :</strong></dt><dd></dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Positional and keyword arguments, passed straight through the <code class="docutils literal notranslate"><span class="pre">dict</span></code>
constructor.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.PerArrayDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_rows=0</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArrayDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.PerArrayDict.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArrayDict.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends the elements of another <a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a>.</p>
<p>That is, for each entry in this dictionary, we append the elements
coming from the other dictionary at the corresponding entry.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a> object</span></dt><dd><p>Its data will be appended to the data of this dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The keys in both dictionaries must be the same.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="perarraysequencedict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArraySequenceDict</span></code></a><a class="headerlink" href="#perarraysequencedict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.PerArraySequenceDict">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">PerArraySequenceDict</code><span class="sig-paren">(</span><em class="sig-param">n_rows=0</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.tractogram.PerArrayDict</span></code></a></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values.  The elements must also be <code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code>.</p>
<p>In addition, it makes sure the amount of data contained in those array
sequences matches the number of elements given at the instantiation
of the instance.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.PerArraySequenceDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_rows=0</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.PerArraySequenceDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sliceabledatadict">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="nibabel.streamlines.tractogram.SliceableDataDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">SliceableDataDict</span></code></a><a class="headerlink" href="#sliceabledatadict" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.SliceableDataDict">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">SliceableDataDict</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.SliceableDataDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></p>
<p>Dictionary for which key access can do slicing on the values.</p>
<p>This container behaves like a standard dictionary but extends key access to
allow keys for key access to be indices slicing into the contained ndarray
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args :</strong></dt><dd></dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Positional and keyword arguments, passed straight through the <code class="docutils literal notranslate"><span class="pre">dict</span></code>
constructor.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.SliceableDataDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.SliceableDataDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogram">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a><a class="headerlink" href="#tractogram" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.Tractogram">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">Tractogram</code><span class="sig-paren">(</span><em class="sig-param">streamlines=None</em>, <em class="sig-param">data_per_streamline=None</em>, <em class="sig-param">data_per_point=None</em>, <em class="sig-param">affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Container for streamlines and their data information.</p>
<p>Streamlines of a tractogram can be in any coordinate system of your
choice as long as you provide the correct <cite>affine_to_rasmm</cite> matrix, at
construction time. When applied to streamlines coordinates, that
transformation matrix should bring the streamlines back to world space
(RAS+ and mm space) <a class="footnote-reference brackets" href="#id11" id="id9">5</a>.</p>
<p>Moreover, when streamlines are mapped back to voxel space <a class="footnote-reference brackets" href="#id12" id="id10">6</a>, a
streamline point located at an integer coordinate (i,j,k) is considered
to be at the center of the corresponding voxel. This is in contrast with
other conventions where it might have referred to a corner.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id9">5</a></span></dt>
<dd><p><a class="reference external" href="http://nipy.org/nibabel/coordinate_systems.html#naming-reference-spaces">http://nipy.org/nibabel/coordinate_systems.html#naming-reference-spaces</a></p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id10">6</a></span></dt>
<dd><p><a class="reference external" href="http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space">http://nipy.org/nibabel/coordinate_systems.html#voxel-coordinates-are-in-voxel-space</a></p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code> object</span></dt><dd><p>Sequence of <span class="math notranslate nohighlight">\(T\)</span> streamlines. Each streamline is an ndarray of
shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArrayDict" title="nibabel.streamlines.tractogram.PerArrayDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArrayDict</span></code></a> object</span></dt><dd><p>Dictionary where the items are (str, 2D array).  Each key represents a
piece of information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every streamline, and its
associated value is a 2D array of shape (<span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(P_i\)</span>) where <span class="math notranslate nohighlight">\(T\)</span> is the
number of streamlines and <span class="math notranslate nohighlight">\(P_i\)</span> is the number of values to store for
that particular piece of information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.PerArraySequenceDict" title="nibabel.streamlines.tractogram.PerArraySequenceDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">PerArraySequenceDict</span></code></a> object</span></dt><dd><p>Dictionary where the items are (str, <code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code>).  Each key
represents a piece of information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every point
of every streamline, and its associated value is an iterable of
ndarrays of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points
for a particular streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span> is the number values to store
for that particular piece of information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">iterable of ndarrays or <code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code>, optional</span></dt><dd><p>Sequence of <span class="math notranslate nohighlight">\(T\)</span> streamlines. Each streamline is an ndarray of
shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier">dict of iterable of ndarrays, optional</span></dt><dd><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
streamline, and its associated value is an iterable of ndarrays of
shape (<span class="math notranslate nohighlight">\(P_i\)</span>,) where <span class="math notranslate nohighlight">\(P_i\)</span> is the number of scalar values to store
for that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier">dict of iterable of ndarrays, optional</span></dt><dd><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is an iterable
of ndarrays of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of
points for a particular streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span> is the number
scalar values to store for that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>affine_to_rasmm</strong><span class="classifier">ndarray of shape (4, 4) or None, optional</span></dt><dd><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">streamlines=None</em>, <em class="sig-param">data_per_streamline=None</em>, <em class="sig-param">data_per_point=None</em>, <em class="sig-param">affine_to_rasmm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">iterable of ndarrays or <code class="xref py py-class docutils literal notranslate"><span class="pre">ArraySequence</span></code>, optional</span></dt><dd><p>Sequence of <span class="math notranslate nohighlight">\(T\)</span> streamlines. Each streamline is an ndarray of
shape (<span class="math notranslate nohighlight">\(N_t\)</span>, 3) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of points of
streamline <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>data_per_streamline</strong><span class="classifier">dict of iterable of ndarrays, optional</span></dt><dd><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
streamline, and its associated value is an iterable of ndarrays of
shape (<span class="math notranslate nohighlight">\(P_i\)</span>,) where <span class="math notranslate nohighlight">\(P_i\)</span> is the number of scalar values to store
for that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>data_per_point</strong><span class="classifier">dict of iterable of ndarrays, optional</span></dt><dd><p>Dictionary where the items are (str, iterable).
Each key represents an information <span class="math notranslate nohighlight">\(i\)</span> to be kept alongside every
point of every streamline, and its associated value is an iterable
of ndarrays of shape (<span class="math notranslate nohighlight">\(N_t\)</span>, <span class="math notranslate nohighlight">\(M_i\)</span>) where <span class="math notranslate nohighlight">\(N_t\)</span> is the number of
points for a particular streamline <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(M_i\)</span> is the number
scalar values to store for that particular information <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt><strong>affine_to_rasmm</strong><span class="classifier">ndarray of shape (4, 4) or None, optional</span></dt><dd><p>Transformation matrix that brings the streamlines contained in
this tractogram to <em>RAS+</em> and <em>mm</em> space where coordinate (0,0,0)
refers to the center of the voxel. By default, the streamlines
are in an unknown space, i.e. affine_to_rasmm is None.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.affine_to_rasmm">
<em class="property">property </em><code class="sig-name descname">affine_to_rasmm</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.affine_to_rasmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Affine bringing streamlines in this tractogram to RAS+mm.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.apply_affine">
<code class="sig-name descname">apply_affine</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">lazy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an affine transformation on the points of each streamline.</p>
<p>If <cite>lazy</cite> is not specified, this is performed <em>in-place</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">ndarray of shape (4, 4)</span></dt><dd><p>Transformation that will be applied to every streamline.</p>
</dd>
<dt><strong>lazy</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, streamlines are <em>not</em> transformed in-place and a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object is returned. Otherwise, streamlines
are modified in-place.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> or <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>Tractogram where the streamlines have been transformed according
to the given affine transformation. If the <cite>lazy</cite> option is true,
it returns a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object, otherwise it returns a
reference to this <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object with updated
streamlines.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.data_per_point">
<em class="property">property </em><code class="sig-name descname">data_per_point</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.data_per_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.data_per_streamline">
<em class="property">property </em><code class="sig-name descname">data_per_streamline</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.data_per_streamline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends the data of another <a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a>.</p>
<p>Data that will be appended includes the streamlines and the content
of both dictionaries <cite>data_per_streamline</cite> and <cite>data_per_point</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object</span></dt><dd><p>Its data will be appended to the data of this tractogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The entries in both dictionaries <cite>self.data_per_streamline</cite> and
<cite>self.data_per_point</cite> must match respectively those contained in
the other tractogram.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.streamlines">
<em class="property">property </em><code class="sig-name descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram.Tractogram.to_world">
<code class="sig-name descname">to_world</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">lazy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.Tractogram.to_world" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings the streamlines to world space (i.e. RAS+ and mm).</p>
<p>If <cite>lazy</cite> is not specified, this is performed <em>in-place</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lazy</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, streamlines are <em>not</em> transformed in-place and a
<a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object is returned. Otherwise, streamlines
are modified in-place.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tractogram</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> or <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a> object</span></dt><dd><p>Tractogram where the streamlines have been sent to world space.
If the <cite>lazy</cite> option is true, it returns a <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyTractogram" title="nibabel.streamlines.tractogram.LazyTractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyTractogram</span></code></a>
object, otherwise it returns a reference to this
<a class="reference internal" href="#nibabel.streamlines.tractogram.Tractogram" title="nibabel.streamlines.tractogram.Tractogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code></a> object with updated streamlines.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogramitem">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a><a class="headerlink" href="#tractogramitem" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram.TractogramItem">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">TractogramItem</code><span class="sig-paren">(</span><em class="sig-param">streamline</em>, <em class="sig-param">data_for_streamline</em>, <em class="sig-param">data_for_points</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.TractogramItem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class containing information about one streamline.</p>
<p><a class="reference internal" href="#nibabel.streamlines.tractogram.TractogramItem" title="nibabel.streamlines.tractogram.TractogramItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramItem</span></code></a> objects have three public attributes: <cite>streamline</cite>,
<cite>data_for_streamline</cite>, and <cite>data_for_points</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamline</strong><span class="classifier">ndarray shape (N, 3)</span></dt><dd><p>Points of this streamline represented as an ndarray of shape (N, 3)
where N is the number of points.</p>
</dd>
<dt><strong>data_for_streamline</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing some data associated with this particular
streamline. Each key <code class="docutils literal notranslate"><span class="pre">k</span></code> is mapped to a ndarray of shape (Pt,), where
<code class="docutils literal notranslate"><span class="pre">Pt</span></code> is the dimension of the data associated with key <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
</dd>
<dt><strong>data_for_points</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing some data associated to each point of this
particular streamline. Each key <code class="docutils literal notranslate"><span class="pre">k</span></code> is mapped to a ndarray of shape
(Nt, Mk), where <code class="docutils literal notranslate"><span class="pre">Nt</span></code> is the number of points of this streamline and
<code class="docutils literal notranslate"><span class="pre">Mk</span></code> is the dimension of the data associated with key <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.streamlines.tractogram.TractogramItem.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">streamline</em>, <em class="sig-param">data_for_streamline</em>, <em class="sig-param">data_for_points</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.TractogramItem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="is-data-dict">
<h3>is_data_dict<a class="headerlink" href="#is-data-dict" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.tractogram.is_data_dict">
<code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">is_data_dict</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.is_data_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>obj</cite> seems to implement the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataDict</span></code> API</p>
</dd></dl>

</div>
<div class="section" id="is-lazy-dict">
<h3>is_lazy_dict<a class="headerlink" href="#is-lazy-dict" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.tractogram.is_lazy_dict">
<code class="sig-prename descclassname">nibabel.streamlines.tractogram.</code><code class="sig-name descname">is_lazy_dict</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram.is_lazy_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>obj</cite> seems to implement the <a class="reference internal" href="#nibabel.streamlines.tractogram.LazyDict" title="nibabel.streamlines.tractogram.LazyDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyDict</span></code></a> API</p>
</dd></dl>

</div>
<div class="section" id="dataerror">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataError" title="nibabel.streamlines.tractogram_file.DataError"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataError</span></code></a><a class="headerlink" href="#dataerror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.DataError">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">DataError</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when data is missing or inconsistent in a tractogram file.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.DataError.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="datawarning">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.DataWarning" title="nibabel.streamlines.tractogram_file.DataWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataWarning</span></code></a><a class="headerlink" href="#datawarning" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.DataWarning">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">DataWarning</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Base class for warnings about tractogram file data.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.DataWarning.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.DataWarning.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="extensionwarning">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="nibabel.streamlines.tractogram_file.ExtensionWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionWarning</span></code></a><a class="headerlink" href="#extensionwarning" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.ExtensionWarning">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">ExtensionWarning</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.ExtensionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Base class for warnings about tractogram file extension.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.ExtensionWarning.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.ExtensionWarning.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="headererror">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderError" title="nibabel.streamlines.tractogram_file.HeaderError"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderError</span></code></a><a class="headerlink" href="#headererror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.HeaderError">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">HeaderError</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when a tractogram file header contains invalid information.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.HeaderError.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="headerwarning">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="nibabel.streamlines.tractogram_file.HeaderWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderWarning</span></code></a><a class="headerlink" href="#headerwarning" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.HeaderWarning">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">HeaderWarning</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Base class for warnings about tractogram file header.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.HeaderWarning.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.HeaderWarning.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tractogramfile">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code></a><a class="headerlink" href="#tractogramfile" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">TractogramFile</code><span class="sig-paren">(</span><em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Convenience class to encapsulate tractogram file format.</p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.affine">
<em class="property">property </em><code class="sig-name descname">affine</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>voxmm -&gt; rasmm affine.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.create_empty_header">
<em class="property">classmethod </em><code class="sig-name descname">create_empty_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.create_empty_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an empty header for this streamlines file format.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.header">
<em class="property">property </em><code class="sig-name descname">header</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.is_correct_format">
<em class="property">abstract classmethod </em><code class="sig-name descname">is_correct_format</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.is_correct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the file has the right streamlines file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the
beginning of the header).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_correct_format</strong><span class="classifier">{True, False}</span></dt><dd><p>Returns True if <cite>fileobj</cite> is in the right streamlines file format,
otherwise returns False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.load">
<em class="property">abstract classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">lazy_load=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines from a filename or file-like object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to a streamlines file (and ready to read from the
beginning of the header).</p>
</dd>
<dt><strong>lazy_load</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, load streamlines in a lazy manner i.e. they will not be
kept in memory. Otherwise, load all streamlines in memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tractogram_file</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractogramFile</span></code></a> object</span></dt><dd><p>Returns an object containing tractogram data and header
information.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.save">
<em class="property">abstract </em><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves streamlines to a filename or file-like object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
opened and ready to write.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.streamlines">
<em class="property">property </em><code class="sig-name descname">streamlines</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.streamlines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.TractogramFile.tractogram">
<em class="property">property </em><code class="sig-name descname">tractogram</code><a class="headerlink" href="#nibabel.streamlines.tractogram_file.TractogramFile.tractogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="abstractclassmethod">
<h3><a class="reference internal" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="nibabel.streamlines.tractogram_file.abstractclassmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">abstractclassmethod</span></code></a><a class="headerlink" href="#abstractclassmethod" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.tractogram_file.abstractclassmethod">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.tractogram_file.</code><code class="sig-name descname">abstractclassmethod</code><span class="sig-paren">(</span><em class="sig-param">callable</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.abstractclassmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></p>
<dl class="method">
<dt id="nibabel.streamlines.tractogram_file.abstractclassmethod.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">callable</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.tractogram_file.abstractclassmethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trkfile">
<h3><a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrkFile</span></code></a><a class="headerlink" href="#trkfile" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="nibabel.streamlines.trk.TrkFile">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.streamlines.trk.</code><code class="sig-name descname">TrkFile</code><span class="sig-paren">(</span><em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.streamlines.tractogram_file.TractogramFile" title="nibabel.streamlines.tractogram_file.TractogramFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.tractogram_file.TractogramFile</span></code></a></p>
<p>Convenience class to encapsulate TRK file format.</p>
<p class="rubric">Notes</p>
<p>TrackVis (so its file format: TRK) considers the streamline coordinate
(0,0,0) to be in the corner of the voxel whereas NiBabel’s streamlines
internal representation (Voxel space) assumes (0,0,0) to be in the
center of the voxel.</p>
<p>Thus, streamlines are shifted by half a voxel on load and are shifted
back on save.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object</span></dt><dd><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrkFile</span></code></a>.</p>
</dd>
<dt><strong>header</strong><span class="classifier">dict, optional</span></dt><dd><p>Metadata associated to this tractogram file.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center
of the voxel.</p>
<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tractogram</em>, <em class="sig-param">header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>tractogram</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tractogram</span></code> object</span></dt><dd><p>Tractogram that will be contained in this <a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrkFile</span></code></a>.</p>
</dd>
<dt><strong>header</strong><span class="classifier">dict, optional</span></dt><dd><p>Metadata associated to this tractogram file.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the tractogram are assumed to be in <em>RAS+</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center
of the voxel.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.HEADER_SIZE">
<code class="sig-name descname">HEADER_SIZE</code><em class="property"> = 1000</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.HEADER_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.MAGIC_NUMBER">
<code class="sig-name descname">MAGIC_NUMBER</code><em class="property"> = b'TRACK'</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.MAGIC_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_POINT">
<code class="sig-name descname">SUPPORTS_DATA_PER_POINT</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_POINT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_STREAMLINE">
<code class="sig-name descname">SUPPORTS_DATA_PER_STREAMLINE</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.SUPPORTS_DATA_PER_STREAMLINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.create_empty_header">
<em class="property">classmethod </em><code class="sig-name descname">create_empty_header</code><span class="sig-paren">(</span><em class="sig-param">endianness=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.create_empty_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty compliant TRK header as dict</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.is_correct_format">
<em class="property">classmethod </em><code class="sig-name descname">is_correct_format</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.is_correct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the file is in TRK format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to read from the beginning
of the TRK header data). Note that calling this function
does not change the file position.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_correct_format</strong><span class="classifier">{True, False}</span></dt><dd><p>Returns True if <cite>fileobj</cite> is compatible with TRK format,
otherwise returns False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads streamlines from a filename or file-like object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to read from the beginning
of the TRK header). Note that calling this function
does not change the file position.</p>
</dd>
<dt><strong>lazy_load</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>If True, load streamlines in a lazy manner i.e. they will not be
kept in memory. Otherwise, load all streamlines in memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>trk_file</strong><span class="classifier"><a class="reference internal" href="#nibabel.streamlines.trk.TrkFile" title="nibabel.streamlines.trk.TrkFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrkFile</span></code></a> object</span></dt><dd><p>Returns an object containing tractogram data and header
information.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Streamlines of the returned tractogram are assumed to be in <em>RAS</em>
and <em>mm</em> space where coordinate (0,0,0) refers to the center of the
voxel.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.streamlines.trk.TrkFile.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.TrkFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save tractogram to a filename or file-like object using TRK format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">string or file-like object</span></dt><dd><p>If string, a filename; otherwise an open file-like object
pointing to TRK file (and ready to write from the beginning
of the TRK header data).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="decode-value-from-name">
<h3>decode_value_from_name<a class="headerlink" href="#decode-value-from-name" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.decode_value_from_name">
<code class="sig-prename descclassname">nibabel.streamlines.trk.</code><code class="sig-name descname">decode_value_from_name</code><span class="sig-paren">(</span><em class="sig-param">encoded_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.decode_value_from_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a value that has been encoded in the last bytes of a string.</p>
<p>Check <a class="reference internal" href="#nibabel.streamlines.trk.encode_value_in_name" title="nibabel.streamlines.trk.encode_value_in_name"><code class="xref py py-func docutils literal notranslate"><span class="pre">encode_value_in_name()</span></code></a> to see how the value has been encoded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>encoded_name</strong><span class="classifier">bytes</span></dt><dd><p>Name in which a value has been encoded or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>name</strong><span class="classifier">bytes</span></dt><dd><p>Name without the encoded value.</p>
</dd>
<dt><strong>value</strong><span class="classifier">int</span></dt><dd><p>Value decoded from the name.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="encode-value-in-name">
<h3>encode_value_in_name<a class="headerlink" href="#encode-value-in-name" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.encode_value_in_name">
<code class="sig-prename descclassname">nibabel.streamlines.trk.</code><code class="sig-name descname">encode_value_in_name</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">name</em>, <em class="sig-param">max_name_len=20</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.encode_value_in_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>name</cite> as fixed-length string, appending <cite>value</cite> as string.</p>
<p>Form output from <cite>name</cite> if <cite>value &lt;= 1</cite> else <cite>name</cite> + <code class="docutils literal notranslate"><span class="pre">\</span></code> +
str(value).</p>
<p>Return output as fixed length string length <cite>max_name_len</cite>, padded with
<code class="docutils literal notranslate"><span class="pre">\</span></code>.</p>
<p>This function also verifies that the modified length of name is less than
<cite>max_name_len</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">int</span></dt><dd><p>Integer value to encode.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name to which we may append an ascii / latin-1 representation of
<cite>value</cite>.</p>
</dd>
<dt><strong>max_name_len</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum length of byte string that output can have.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>encoded_name</strong><span class="classifier">bytes</span></dt><dd><p>Name maybe followed by <code class="docutils literal notranslate"><span class="pre">\</span></code> and ascii / latin-1 representation of
<cite>value</cite>, padded with <code class="docutils literal notranslate"><span class="pre">\</span></code> bytes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="get-affine-rasmm-to-trackvis">
<h3>get_affine_rasmm_to_trackvis<a class="headerlink" href="#get-affine-rasmm-to-trackvis" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.get_affine_rasmm_to_trackvis">
<code class="sig-prename descclassname">nibabel.streamlines.trk.</code><code class="sig-name descname">get_affine_rasmm_to_trackvis</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.get_affine_rasmm_to_trackvis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="get-affine-trackvis-to-rasmm">
<h3>get_affine_trackvis_to_rasmm<a class="headerlink" href="#get-affine-trackvis-to-rasmm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.trk.get_affine_trackvis_to_rasmm">
<code class="sig-prename descclassname">nibabel.streamlines.trk.</code><code class="sig-name descname">get_affine_trackvis_to_rasmm</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.trk.get_affine_trackvis_to_rasmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get affine mapping trackvis voxelmm space to RAS+ mm space</p>
<p>The streamlines in a trackvis file are in ‘voxelmm’ space, where the
coordinates refer to the corner of the voxel.</p>
<p>Compute the affine matrix that will bring them back to RAS+ mm space, where
the coordinates refer to the center of the voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>header</strong><span class="classifier">dict or ndarray</span></dt><dd><p>Dict or numpy structured array containing trackvis header.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>aff_tv2ras</strong><span class="classifier">shape (4, 4) array</span></dt><dd><p>Affine array mapping coordinates in ‘voxelmm’ space to RAS+ mm space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="get-affine-from-reference">
<h3>get_affine_from_reference<a class="headerlink" href="#get-affine-from-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.utils.get_affine_from_reference">
<code class="sig-prename descclassname">nibabel.streamlines.utils.</code><code class="sig-name descname">get_affine_from_reference</code><span class="sig-paren">(</span><em class="sig-param">ref</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.utils.get_affine_from_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the affine defining the reference space.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ref</strong><span class="classifier">str or <code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object or ndarray shape (4, 4)</span></dt><dd><p>If str then it’s the filename of reference file that will be loaded
using <code class="xref py py-func docutils literal notranslate"><span class="pre">nibabel.load()</span></code> in order to obtain the affine.
If <code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object then the affine is obtained from it.
If ndarray shape (4, 4) then it’s the affine.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">ndarray (4, 4)</span></dt><dd><p>Transformation matrix mapping voxel space to RAS+mm space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="peek-next">
<h3>peek_next<a class="headerlink" href="#peek-next" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nibabel.streamlines.utils.peek_next">
<code class="sig-prename descclassname">nibabel.streamlines.utils.</code><code class="sig-name descname">peek_next</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.streamlines.utils.peek_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Peek next element of iterable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iterable</strong></dt><dd><p>Iterable to peek the next element from.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>next_item</dt><dd><p>Element peeked from <cite>iterable</cite>.</p>
</dd>
<dt>new_iterable</dt><dd><p>Iterable behaving like if the original <cite>iterable</cite> was untouched.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2020, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>