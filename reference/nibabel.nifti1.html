
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Neuroimaging in Python &#8212; NiBabel 3.2.0 documentation</title>
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="nifti2" href="nibabel.nifti2.html" />
    <link rel="prev" title="nicom" href="nibabel.nicom.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div class="row" style="display: flex; flex-direction: row; flex-wrap: wrap; width: 100%;">
  <div class="column" style="background-color: white; display: flex; flex-direction: column; flex: 0 0 140px; padding-left: 2px; padding-bottom:2px; padding-top:2px;">
    <img src="../_static/nibabel-logo.svg" class="logo" alt="Logo" width="130px"/>
  </div>
  <div class="column" style="background-color: white; text-align: left; padding-left: 10px; padding-bottom:50px; padding-top:20px; background-repeat: no-repeat; display: flex; flex-direction: column; flex-basis: 100%; flex: 1;">
    <h1>NiBabel</h1>
    <h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.nifti2.html" title="nifti2"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.nicom.html" title="nicom"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nifti1</span></code></a><ul>
<li><a class="reference internal" href="#nifti1dicomextension"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1DicomExtension</span></code></a></li>
<li><a class="reference internal" href="#nifti1extension"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Extension</span></code></a></li>
<li><a class="reference internal" href="#nifti1extensions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Extensions</span></code></a></li>
<li><a class="reference internal" href="#nifti1header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a></li>
<li><a class="reference internal" href="#nifti1image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Image</span></code></a></li>
<li><a class="reference internal" href="#nifti1pair"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Pair</span></code></a></li>
<li><a class="reference internal" href="#nifti1pairheader"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1PairHeader</span></code></a></li>
<li><a class="reference internal" href="#load">load</a></li>
<li><a class="reference internal" href="#save">save</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.nicom.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nicom</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.nifti2.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nifti2</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.nifti1.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.nifti1">
<span id="nifti1"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">nifti1</span></code><a class="headerlink" href="#module-nibabel.nifti1" title="Permalink to this headline">¶</a></h1>
<p>Read / write access to NIfTI1 image format</p>
<p>NIfTI1 format defined at <a class="reference external" href="http://nifti.nimh.nih.gov/nifti-1/">http://nifti.nimh.nih.gov/nifti-1/</a></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1DicomExtension" title="nibabel.nifti1.Nifti1DicomExtension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1DicomExtension</span></code></a>(code, content[, parent_hdr])</p></td>
<td><p>NIfTI1 DICOM header extension</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1Extension" title="nibabel.nifti1.Nifti1Extension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1Extension</span></code></a>(code, content)</p></td>
<td><p>Baseclass for NIfTI1 header extensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1Extensions" title="nibabel.nifti1.Nifti1Extensions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1Extensions</span></code></a></p></td>
<td><p>Simple extension collection, implemented as a list-subclass.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a>([binaryblock, endianness, …])</p></td>
<td><p>Class for NIfTI1 header</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1Image" title="nibabel.nifti1.Nifti1Image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1Image</span></code></a>(dataobj, affine[, header, …])</p></td>
<td><p>Class for single file NIfTI1 format image</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair" title="nibabel.nifti1.Nifti1Pair"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1Pair</span></code></a>(dataobj, affine[, header, extra, …])</p></td>
<td><p>Class for NIfTI1 format image, header pair</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.nifti1.Nifti1PairHeader" title="nibabel.nifti1.Nifti1PairHeader"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nifti1PairHeader</span></code></a>([binaryblock, endianness, …])</p></td>
<td><p>Class for NIfTI1 pair header</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.nifti1.load" title="nibabel.nifti1.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(filename)</p></td>
<td><p>Load NIfTI1 single or pair from <cite>filename</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.nifti1.save" title="nibabel.nifti1.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(img, filename)</p></td>
<td><p>Save NIfTI1 single or pair to <cite>filename</cite></p></td>
</tr>
</tbody>
</table>
<div class="section" id="nifti1dicomextension">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1DicomExtension" title="nibabel.nifti1.Nifti1DicomExtension"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1DicomExtension</span></code></a><a class="headerlink" href="#nifti1dicomextension" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1DicomExtension">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1DicomExtension</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">content</em>, <em class="sig-param">parent_hdr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1DicomExtension" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.nifti1.Nifti1Extension" title="nibabel.nifti1.Nifti1Extension"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.nifti1.Nifti1Extension</span></code></a></p>
<p>NIfTI1 DICOM header extension</p>
<p>This class is a thin wrapper around pydicom to read a binary DICOM
byte string. If pydicom is available, content is exposed as a Dicom Dataset.
Otherwise, this silently falls back to the standard NiftiExtension class
and content is the raw bytestring loaded directly from the nifti file
header.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>code</strong><span class="classifier">int or str</span></dt><dd><p>Canonical extension code as defined in the NIfTI standard, given
either as integer or corresponding label
(see <code class="xref py py-data docutils literal notranslate"><span class="pre">extension_codes</span></code>)</p>
</dd>
<dt><strong>content</strong><span class="classifier">bytes or pydicom Dataset or None</span></dt><dd><p>Extension content - either a bytestring as read from the NIfTI file
header or an existing pydicom Dataset. If a bystestring, the content
is converted into a Dataset on initialization. If None, a new empty
Dataset is created.</p>
</dd>
<dt><strong>parent_hdr</strong><span class="classifier"><a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a>, optional</span></dt><dd><p>If a dicom extension belongs to an existing
<a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a>, it may be provided here to
ensure that the DICOM dataset is written with correctly corresponding
endianness; otherwise it is assumed the dataset is little endian.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>code should always be 2 for DICOM.</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1DicomExtension.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">code</em>, <em class="sig-param">content</em>, <em class="sig-param">parent_hdr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1DicomExtension.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>code</strong><span class="classifier">int or str</span></dt><dd><p>Canonical extension code as defined in the NIfTI standard, given
either as integer or corresponding label
(see <code class="xref py py-data docutils literal notranslate"><span class="pre">extension_codes</span></code>)</p>
</dd>
<dt><strong>content</strong><span class="classifier">bytes or pydicom Dataset or None</span></dt><dd><p>Extension content - either a bytestring as read from the NIfTI file
header or an existing pydicom Dataset. If a bystestring, the content
is converted into a Dataset on initialization. If None, a new empty
Dataset is created.</p>
</dd>
<dt><strong>parent_hdr</strong><span class="classifier"><a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a>, optional</span></dt><dd><p>If a dicom extension belongs to an existing
<a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a>, it may be provided here to
ensure that the DICOM dataset is written with correctly corresponding
endianness; otherwise it is assumed the dataset is little endian.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>code should always be 2 for DICOM.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1extension">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1Extension" title="nibabel.nifti1.Nifti1Extension"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Extension</span></code></a><a class="headerlink" href="#nifti1extension" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1Extension">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1Extension</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">content</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Baseclass for NIfTI1 header extensions.</p>
<p>This class is sufficient to handle very simple text-based extensions, such
as <cite>comment</cite>. More sophisticated extensions should/will be supported by
dedicated subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code</strong><span class="classifier">int or str</span></dt><dd><p>Canonical extension code as defined in the NIfTI standard, given
either as integer or corresponding label
(see <code class="xref py py-data docutils literal notranslate"><span class="pre">extension_codes</span></code>)</p>
</dd>
<dt><strong>content</strong><span class="classifier">str</span></dt><dd><p>Extension content as read from the NIfTI file header. This content is
converted into a runtime representation.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extension.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">code</em>, <em class="sig-param">content</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code</strong><span class="classifier">int or str</span></dt><dd><p>Canonical extension code as defined in the NIfTI standard, given
either as integer or corresponding label
(see <code class="xref py py-data docutils literal notranslate"><span class="pre">extension_codes</span></code>)</p>
</dd>
<dt><strong>content</strong><span class="classifier">str</span></dt><dd><p>Extension content as read from the NIfTI file header. This content is
converted into a runtime representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extension.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension.get_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canonical extension type code.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extension.get_content">
<code class="sig-name descname">get_content</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension.get_content" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extension content in its runtime representation.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extension.get_sizeondisk">
<code class="sig-name descname">get_sizeondisk</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension.get_sizeondisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the extension in the NIfTI file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extension.write_to">
<code class="sig-name descname">write_to</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em>, <em class="sig-param">byteswap</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extension.write_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Write header extensions to fileobj</p>
<p>Write starts at fileobj current file position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">file-like object</span></dt><dd><p>Should implement <code class="docutils literal notranslate"><span class="pre">write</span></code> method</p>
</dd>
<dt><strong>byteswap</strong><span class="classifier">boolean</span></dt><dd><p>Flag if byteswapping the data is required.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1extensions">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1Extensions" title="nibabel.nifti1.Nifti1Extensions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Extensions</span></code></a><a class="headerlink" href="#nifti1extensions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1Extensions">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1Extensions</code><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<p>Simple extension collection, implemented as a list-subclass.</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ecode</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of extensions matching a given <em>ecode</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code</strong><span class="classifier">int | str</span></dt><dd><p>The ecode can be specified either literal or as numerical value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.from_fileobj">
<em class="property">classmethod </em><code class="sig-name descname">from_fileobj</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">size</em>, <em class="sig-param">byteswap</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Read header extensions from a fileobj</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">file-like object</span></dt><dd><p>We begin reading the extensions at the current file position</p>
</dd>
<dt><strong>size</strong><span class="classifier">int</span></dt><dd><p>Number of bytes to read. If negative, fileobj will be read till its
end.</p>
</dd>
<dt><strong>byteswap</strong><span class="classifier">boolean</span></dt><dd><p>Flag if byteswapping the read data is required.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>An extension list. This list might be empty in case not extensions</dt><dd></dd>
<dt>were present in fileobj.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.get_codes">
<code class="sig-name descname">get_codes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.get_codes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the extension code of all available extensions</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.get_sizeondisk">
<code class="sig-name descname">get_sizeondisk</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.get_sizeondisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the complete header extensions in the NIfTI file.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Extensions.write_to">
<code class="sig-name descname">write_to</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em>, <em class="sig-param">byteswap</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Extensions.write_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Write header extensions to fileobj</p>
<p>Write starts at fileobj current file position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">file-like object</span></dt><dd><p>Should implement <code class="docutils literal notranslate"><span class="pre">write</span></code> method</p>
</dd>
<dt><strong>byteswap</strong><span class="classifier">boolean</span></dt><dd><p>Flag if byteswapping the data is required.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1header">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a><a class="headerlink" href="#nifti1header" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1Header">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1Header</code><span class="sig-paren">(</span><em class="sig-param">binaryblock=None</em>, <em class="sig-param">endianness=None</em>, <em class="sig-param">check=True</em>, <em class="sig-param">extensions=()</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spm99analyze.html#nibabel.spm99analyze.SpmAnalyzeHeader" title="nibabel.spm99analyze.SpmAnalyzeHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.spm99analyze.SpmAnalyzeHeader</span></code></a></p>
<p>Class for NIfTI1 header</p>
<p>The NIfTI1 header has many more coded fields than the simpler Analyze
variants.  NIfTI1 headers also have extensions.</p>
<p>Nifti allows the header to be a separate file, as part of a nifti image /
header pair, or to precede the data in a single file.  The object needs to
know which type it is, in order to manage the voxel offset pointing to the
data, extension reading, and writing the correct magic string.</p>
<p>This class handles the header-preceding-data case.</p>
<p>Initialize header from binary data block and extensions</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">binaryblock=None</em>, <em class="sig-param">endianness=None</em>, <em class="sig-param">check=True</em>, <em class="sig-param">extensions=()</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize header from binary data block and extensions</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of header</p>
<p>Take reference to extensions as well as copy of header contents</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.default_structarr">
<em class="property">classmethod </em><code class="sig-name descname">default_structarr</code><span class="sig-paren">(</span><em class="sig-param">endianness=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.default_structarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create empty header binary block with given endianness</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.exts_klass">
<code class="sig-name descname">exts_klass</code><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.exts_klass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.nifti1.Nifti1Extensions" title="nibabel.nifti1.Nifti1Extensions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Extensions</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.from_fileobj">
<em class="property">classmethod </em><code class="sig-name descname">from_fileobj</code><span class="sig-paren">(</span><em class="sig-param">fileobj</em>, <em class="sig-param">endianness=None</em>, <em class="sig-param">check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return read structure with given or guessed endiancode</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">file-like object</span></dt><dd><p>Needs to implement <code class="docutils literal notranslate"><span class="pre">read</span></code> method</p>
</dd>
<dt><strong>endianness</strong><span class="classifier">None or endian code, optional</span></dt><dd><p>Code specifying endianness of read data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>wstr</strong><span class="classifier">WrapStruct object</span></dt><dd><p>WrapStruct object initialized from data in fileobj</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.from_header">
<em class="property">classmethod </em><code class="sig-name descname">from_header</code><span class="sig-paren">(</span><em class="sig-param">header=None</em>, <em class="sig-param">check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.from_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to create header from another header</p>
<p>Extend Analyze header copy by copying extensions from other Nifti
types.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>header</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Header</span></code> instance or mapping</span></dt><dd><p>a header of this class, or another class of header for
conversion to this type</p>
</dd>
<dt><strong>check</strong><span class="classifier">{True, False}</span></dt><dd><p>whether to check header for integrity</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hdr</strong><span class="classifier">header instance</span></dt><dd><p>fresh header instance of our own class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_best_affine">
<code class="sig-name descname">get_best_affine</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_best_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Select best of available transforms</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_data_shape">
<code class="sig-name descname">get_data_shape</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_data_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get shape of data</p>
<p class="rubric">Notes</p>
<p>Applies freesurfer hack for large vectors described in <a class="reference external" href="https://github.com/nipy/nibabel/issues/100">issue 100</a> and
<a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82">save_nifti.m</a>.</p>
<p>Allows for freesurfer hack for 7th order icosahedron surface described
in <a class="reference external" href="https://github.com/nipy/nibabel/issues/309">issue 309</a>, <a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89">load_nifti.m</a>, and <a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56">save_nifti.m</a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Expanding number of dimensions gets default zooms</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_dim_info">
<code class="sig-name descname">get_dim_info</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_dim_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets NIfTI MRI slice etc dimension information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq</strong><span class="classifier">{None,0,1,2}</span></dt><dd><p>Which data array axis is frequency encode direction</p>
</dd>
<dt><strong>phase</strong><span class="classifier">{None,0,1,2}</span></dt><dd><p>Which data array axis is phase encode direction</p>
</dd>
<dt><strong>slice</strong><span class="classifier">{None,0,1,2}</span></dt><dd><p>Which data array axis is slice encode direction</p>
</dd>
<dt>where <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">array</span></code> is the array returned by <code class="docutils literal notranslate"><span class="pre">get_data</span></code></dt><dd></dd>
<dt>Because NIfTI1 files are natively Fortran indexed:</dt><dd><p>0 is fastest changing in file
1 is medium changing in file
2 is slowest changing in file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">None</span></code> means the axis appears not to be specified.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>See set_dim_info function</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_intent">
<code class="sig-name descname">get_intent</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">code_repr='label'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_intent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get intent code, parameters and name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code_repr</strong><span class="classifier">string</span></dt><dd><p>string giving output form of intent code representation.
Default is ‘label’; use ‘code’ for integer representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>code</strong><span class="classifier">string or integer</span></dt><dd><p>intent code, or string describing code</p>
</dd>
<dt><strong>parameters</strong><span class="classifier">tuple</span></dt><dd><p>parameters for the intent</p>
</dd>
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>intent name</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="s1">&#39;t test&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some score&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;t test&#39;, (10.0,), &#39;some score&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">(</span><span class="s1">&#39;code&#39;</span><span class="p">)</span>
<span class="go">(3, (10.0,), &#39;some score&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_n_slices">
<code class="sig-name descname">get_n_slices</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_n_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of slices</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_qform">
<code class="sig-name descname">get_qform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">coded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_qform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 affine matrix from qform parameters in header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coded</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return {affine or None}, and qform code.  If False, just
return affine.  {affine or None} means, return None if qform code
== 0, and affine otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or (4,4) ndarray</span></dt><dd><p>If <cite>coded</cite> is False, always return affine reconstructed from qform
quaternion.  If <cite>coded</cite> is True, return None if qform code is 0,
else return the affine.</p>
</dd>
<dt><strong>code</strong><span class="classifier">int</span></dt><dd><p>Qform code. Only returned if <cite>coded</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_qform_quaternion">
<code class="sig-name descname">get_qform_quaternion</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_qform_quaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute quaternion from b, c, d of quaternion</p>
<p>Fills a value by assuming this is a unit quaternion</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_sform">
<code class="sig-name descname">get_sform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">coded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_sform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 affine matrix from sform parameters in header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coded</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return {affine or None}, and sform code.  If False, just
return affine.  {affine or None} means, return None if sform code
== 0, and affine otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or (4,4) ndarray</span></dt><dd><p>If <cite>coded</cite> is False, always return affine from sform fields. If
<cite>coded</cite> is True, return None if sform code is 0, else return the
affine.</p>
</dd>
<dt><strong>code</strong><span class="classifier">int</span></dt><dd><p>Sform code. Only returned if <cite>coded</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_slice_duration">
<code class="sig-name descname">get_slice_duration</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_slice_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Get slice duration</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slice_duration</strong><span class="classifier">float</span></dt><dd><p>time to acquire one slice</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The NIfTI1 spec appears to require the slice dimension to be
defined for slice_duration to have meaning.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="nb">slice</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_slice_duration</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%0.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hdr</span><span class="o">.</span><span class="n">get_slice_duration</span><span class="p">())</span>
<span class="go">0.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_slice_times">
<code class="sig-name descname">get_slice_times</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_slice_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Get slice times from slice timing information</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slice_times</strong><span class="classifier">tuple</span></dt><dd><p>Times of acquisition of slices, where 0 is the beginning of
the acquisition, ordered by position in file.  nifti allows
slices at the top and bottom of the volume to be excluded from
the standard slice timing specification, and calls these
“padding slices”.  We give padding slices <code class="docutils literal notranslate"><span class="pre">None</span></code> as a time
of acquisition</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="nb">slice</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_slice_duration</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;slice_code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_order_codes</span><span class="p">[</span><span class="s1">&#39;sequential increasing&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slice_times</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">.</span><span class="n">get_slice_times</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">slice_times</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_slope_inter">
<code class="sig-name descname">get_slope_inter</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_slope_inter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data scaling (slope) and DC offset (intercept) from header data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slope</strong><span class="classifier">None or float</span></dt><dd><p>scaling (slope).  None if there is no valid scaling from these
fields</p>
</dd>
<dt><strong>inter</strong><span class="classifier">None or float</span></dt><dd><p>offset (intercept). None if there is no valid scaling or if offset
is not finite.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_slope_inter</span><span class="p">()</span>
<span class="go">(1.0, 0.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;scl_slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_slope_inter</span><span class="p">()</span>
<span class="go">(None, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;scl_slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_slope_inter</span><span class="p">()</span>
<span class="go">(None, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;scl_slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;scl_inter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_slope_inter</span><span class="p">()</span>
<span class="go">(1.0, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;scl_inter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_slope_inter</span><span class="p">()</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">HeaderDataError</span>: <span class="n">Valid slope but invalid intercept inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.get_xyzt_units">
<code class="sig-name descname">get_xyzt_units</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.get_xyzt_units" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.has_data_intercept">
<code class="sig-name descname">has_data_intercept</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.has_data_intercept" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.has_data_slope">
<code class="sig-name descname">has_data_slope</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.has_data_slope" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.is_single">
<code class="sig-name descname">is_single</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.is_single" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.may_contain_header">
<em class="property">classmethod </em><code class="sig-name descname">may_contain_header</code><span class="sig-paren">(</span><em class="sig-param">binaryblock</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.may_contain_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.pair_magic">
<code class="sig-name descname">pair_magic</code><em class="property"> = b'ni1'</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.pair_magic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.pair_vox_offset">
<code class="sig-name descname">pair_vox_offset</code><em class="property"> = 0</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.pair_vox_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.quaternion_threshold">
<code class="sig-name descname">quaternion_threshold</code><em class="property"> = -3.5762786865234375e-07</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.quaternion_threshold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_data_shape">
<code class="sig-name descname">set_data_shape</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_data_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Set shape of data  # noqa</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ndims</span> <span class="pre">==</span> <span class="pre">len(shape)</span></code> then we set zooms for dimensions higher than
<code class="docutils literal notranslate"><span class="pre">ndims</span></code> to 1.0</p>
<p>Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
Nifti surface files, the first dimension is assumed to correspond to
vertices/nodes on a surface, and dimensions two and three are
constrained to have depth of 1. Dimensions 4-7 are constrained only by
type bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">sequence</span></dt><dd><p>sequence of integers specifying data array shape</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Applies freesurfer hack for large vectors described in <a class="reference external" href="https://github.com/nipy/nibabel/issues/100">issue 100</a> and
<a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82">save_nifti.m</a>.</p>
<p>Allows for freesurfer hack for 7th order icosahedron surface described
in <a class="reference external" href="https://github.com/nipy/nibabel/issues/309">issue 309</a>, <a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89">load_nifti.m</a>, and <a class="reference external" href="https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56">save_nifti.m</a>.</p>
<p>The Nifti1 <a class="reference external" href="http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h">standard header</a> allows for the following “point set”
definition of a surface, not currently implemented in nibabel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">signify</span> <span class="n">that</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">value</span> <span class="n">at</span> <span class="n">each</span> <span class="n">voxel</span> <span class="ow">is</span> <span class="n">really</span> <span class="n">a</span>
<span class="n">spatial</span> <span class="n">coordinate</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="n">the</span> <span class="n">vertices</span> <span class="ow">or</span> <span class="n">nodes</span> <span class="n">of</span> <span class="n">a</span> <span class="n">surface</span> <span class="n">mesh</span><span class="p">):</span>
  <span class="o">-</span> <span class="n">dataset</span> <span class="n">must</span> <span class="n">have</span> <span class="n">a</span> <span class="mi">5</span><span class="n">th</span> <span class="n">dimension</span>
  <span class="o">-</span> <span class="n">intent_code</span> <span class="n">must</span> <span class="n">be</span> <span class="n">NIFTI_INTENT_POINTSET</span>
  <span class="o">-</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="o">-</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span>
  <span class="o">-</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="n">dim</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="n">must</span> <span class="n">be</span> <span class="n">the</span> <span class="n">dimensionality</span> <span class="n">of</span> <span class="n">space</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="n">D</span> <span class="n">space</span><span class="p">)</span><span class="o">.</span>
  <span class="o">-</span> <span class="n">intent_name</span> <span class="n">may</span> <span class="n">describe</span> <span class="n">the</span> <span class="nb">object</span> <span class="n">these</span> <span class="n">points</span> <span class="n">come</span> <span class="kn">from</span>
    <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="s2">&quot;pial&quot;</span><span class="p">,</span> <span class="s2">&quot;gray/white&quot;</span> <span class="p">,</span> <span class="s2">&quot;EEG&quot;</span><span class="p">,</span> <span class="s2">&quot;MEG&quot;</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_dim_info">
<code class="sig-name descname">set_dim_info</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">phase=None</em>, <em class="sig-param">slice=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_dim_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets nifti MRI slice etc dimension information</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq</strong><span class="classifier">{None, 0, 1, 2}</span></dt><dd><p>axis of data array referring to frequency encoding</p>
</dd>
<dt><strong>phase</strong><span class="classifier">{None, 0, 1, 2}</span></dt><dd><p>axis of data array referring to phase encoding</p>
</dd>
<dt><strong>slice</strong><span class="classifier">{None, 0, 1, 2}</span></dt><dd><p>axis of data array referring to slice encoding</p>
</dd>
<dt><strong>``None`` means the axis is not specified.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is stored in one byte in the header</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_dim_info</span><span class="p">()</span>
<span class="go">(1, 2, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_dim_info</span><span class="p">()</span>
<span class="go">(1, 2, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_dim_info</span><span class="p">()</span>
<span class="go">(None, None, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_dim_info</span><span class="p">()</span>
<span class="go">(1, None, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_intent">
<code class="sig-name descname">set_intent</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">code</em>, <em class="sig-param">params=()</em>, <em class="sig-param">name=''</em>, <em class="sig-param">allow_unknown=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_intent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the intent code, parameters and name</p>
<p>If parameters are not specified, assumed to be all zero. Each
intent code has a set number of parameters associated. If you
specify any parameters, then it will need to be the correct number
(e.g the “f test” intent requires 2).  However, parameters can
also be set in the file data, so we also allow not setting any
parameters (empty parameter tuple).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code</strong><span class="classifier">integer or string</span></dt><dd><p>code specifying nifti intent</p>
</dd>
<dt><strong>params</strong><span class="classifier">list, tuple of scalars</span></dt><dd><p>parameters relating to intent (see intent_codes)
defaults to ().  Unspecified parameters are set to 0.0</p>
</dd>
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>intent name (description). Defaults to ‘’</p>
</dd>
<dt><strong>allow_unknown</strong><span class="classifier">{False, True}, optional</span></dt><dd><p>Allow unknown integer intent codes. If False (the default),
a KeyError is raised on attempts to set the intent
to an unknown code.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># no intent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="s1">&#39;z score&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;z score&#39;, (), &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">(</span><span class="s1">&#39;code&#39;</span><span class="p">)</span>
<span class="go">(5, (), &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="s1">&#39;t test&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some score&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;t test&#39;, (10.0,), &#39;some score&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="s1">&#39;f test&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;another score&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;f test&#39;, (2.0, 10.0), &#39;another score&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="s1">&#39;f test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;f test&#39;, (0.0, 0.0), &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_intent</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="n">allow_unknown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># unknown code</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_intent</span><span class="p">()</span>
<span class="go">(&#39;unknown code 9999&#39;, (), &#39;&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_qform">
<code class="sig-name descname">set_qform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">code=None</em>, <em class="sig-param">strip_shears=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_qform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set qform header values from 4x4 affine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or 4x4 array</span></dt><dd><p>affine transform to write into sform. If None, only set code.</p>
</dd>
<dt><strong>code</strong><span class="classifier">None, string or integer, optional</span></dt><dd><p>String or integer giving meaning of transform in <em>affine</em>.
The default is None.  If code is None, then:</p>
<ul class="simple">
<li><p>If affine is None, <cite>code</cite>-&gt; 0</p></li>
<li><p>If affine not None and existing qform code in header == 0,
<cite>code</cite>-&gt; 2 (aligned)</p></li>
<li><p>If affine not None and existing qform code in header != 0,
<cite>code</cite>-&gt; existing qform code in header</p></li>
</ul>
</dd>
<dt><strong>strip_shears</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to strip shears in <cite>affine</cite>.  If True, shears will be
silently stripped. If False, the presence of shears will raise a
<code class="docutils literal notranslate"><span class="pre">HeaderDataError</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The qform transform only encodes translations, rotations and
zooms. If there are shear components to the <cite>affine</cite> transform, and
<cite>strip_shears</cite> is True (the default), the written qform gives the
closest approximation where the rotation matrix is orthogonal. This is
to allow quaternion representation. The orthogonal representation
enforces orthogonal axes.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>  <span class="c1"># gives 0 - unknown</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_qform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_qform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>  <span class="c1"># gives 2 - aligned</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;talairach&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;scanner&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;qform_code&#39;</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_sform">
<code class="sig-name descname">set_sform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">code=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_sform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sform transform from 4x4 affine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or 4x4 array</span></dt><dd><p>affine transform to write into sform.  If None, only set <cite>code</cite></p>
</dd>
<dt><strong>code</strong><span class="classifier">None, string or integer, optional</span></dt><dd><p>String or integer giving meaning of transform in <em>affine</em>.
The default is None.  If code is None, then:</p>
<ul class="simple">
<li><p>If affine is None, <cite>code</cite>-&gt; 0</p></li>
<li><p>If affine not None and existing sform code in header == 0,
<cite>code</cite>-&gt; 2 (aligned)</p></li>
<li><p>If affine not None and existing sform code in header != 0,
<cite>code</cite>-&gt; existing sform code in header</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>  <span class="c1"># gives 0 - unknown</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_sform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_sform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>  <span class="c1"># gives 2 - aligned</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;talairach&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;scanner&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;sform_code&#39;</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_slice_duration">
<code class="sig-name descname">set_slice_duration</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">duration</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_slice_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Set slice duration</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>duration</strong><span class="classifier">scalar</span></dt><dd><p>time to acquire one slice</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>See <code class="docutils literal notranslate"><span class="pre">get_slice_duration</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_slice_times">
<code class="sig-name descname">set_slice_times</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">slice_times</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_slice_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Set slice times into <em>hdr</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slice_times</strong><span class="classifier">tuple</span></dt><dd><p>tuple of slice times, one value per slice
tuple can include None to indicate no slice time for that slice</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">Nifti1Header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_dim_info</span><span class="p">(</span><span class="nb">slice</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_data_shape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_slice_duration</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">set_slice_times</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span><span class="o">.</span><span class="n">get_value_label</span><span class="p">(</span><span class="s1">&#39;slice_code&#39;</span><span class="p">)</span>
<span class="go">&#39;alternating decreasing&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;slice_end&#39;</span><span class="p">])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_slope_inter">
<code class="sig-name descname">set_slope_inter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">slope</em>, <em class="sig-param">inter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_slope_inter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set slope and / or intercept into header</p>
<p>Set slope and intercept for image data, such that, if the image
data is <code class="docutils literal notranslate"><span class="pre">arr</span></code>, then the scaled image data will be <code class="docutils literal notranslate"><span class="pre">(arr</span> <span class="pre">*</span>
<span class="pre">slope)</span> <span class="pre">+</span> <span class="pre">inter</span></code></p>
<p>(<cite>slope</cite>, <cite>inter</cite>) of (NaN, NaN) is a signal to a containing image to
set <cite>slope</cite>, <cite>inter</cite> automatically on write.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slope</strong><span class="classifier">None or float</span></dt><dd><p>If None, implies <cite>slope</cite>  of NaN. If <cite>slope</cite> is None or NaN then
<cite>inter</cite> should be None or NaN.  Values of 0, Inf or -Inf raise
HeaderDataError</p>
</dd>
<dt><strong>inter</strong><span class="classifier">None or float, optional</span></dt><dd><p>Intercept. If None, implies <cite>inter</cite> of NaN. If <cite>slope</cite> is None or
NaN then <cite>inter</cite> should be None or NaN.  Values of Inf or -Inf raise
HeaderDataError</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.set_xyzt_units">
<code class="sig-name descname">set_xyzt_units</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xyz=None</em>, <em class="sig-param">t=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.set_xyzt_units" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.single_magic">
<code class="sig-name descname">single_magic</code><em class="property"> = b'n+1'</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.single_magic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.single_vox_offset">
<code class="sig-name descname">single_vox_offset</code><em class="property"> = 352</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.single_vox_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Header.template_dtype">
<code class="sig-name descname">template_dtype</code><em class="property"> = dtype([('sizeof_hdr', '&lt;i4'), ('data_type', 'S10'), ('db_name', 'S18'), ('extents', '&lt;i4'), ('session_error', '&lt;i2'), ('regular', 'S1'), ('dim_info', 'u1'), ('dim', '&lt;i2', (8,)), ('intent_p1', '&lt;f4'), ('intent_p2', '&lt;f4'), ('intent_p3', '&lt;f4'), ('intent_code', '&lt;i2'), ('datatype', '&lt;i2'), ('bitpix', '&lt;i2'), ('slice_start', '&lt;i2'), ('pixdim', '&lt;f4', (8,)), ('vox_offset', '&lt;f4'), ('scl_slope', '&lt;f4'), ('scl_inter', '&lt;f4'), ('slice_end', '&lt;i2'), ('slice_code', 'u1'), ('xyzt_units', 'u1'), ('cal_max', '&lt;f4'), ('cal_min', '&lt;f4'), ('slice_duration', '&lt;f4'), ('toffset', '&lt;f4'), ('glmax', '&lt;i4'), ('glmin', '&lt;i4'), ('descrip', 'S80'), ('aux_file', 'S24'), ('qform_code', '&lt;i2'), ('sform_code', '&lt;i2'), ('quatern_b', '&lt;f4'), ('quatern_c', '&lt;f4'), ('quatern_d', '&lt;f4'), ('qoffset_x', '&lt;f4'), ('qoffset_y', '&lt;f4'), ('qoffset_z', '&lt;f4'), ('srow_x', '&lt;f4', (4,)), ('srow_y', '&lt;f4', (4,)), ('srow_z', '&lt;f4', (4,)), ('intent_name', 'S16'), ('magic', 'S4')])</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.template_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Header.write_to">
<code class="sig-name descname">write_to</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fileobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Header.write_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Write structure to fileobj</p>
<p>Write starts at fileobj current file position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fileobj</strong><span class="classifier">file-like object</span></dt><dd><p>Should implement <code class="docutils literal notranslate"><span class="pre">write</span></code> method</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wstr</span> <span class="o">=</span> <span class="n">WrapStruct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_io</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wstr</span><span class="o">.</span><span class="n">write_to</span><span class="p">(</span><span class="n">str_io</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wstr</span><span class="o">.</span><span class="n">binaryblock</span> <span class="o">==</span> <span class="n">str_io</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1image">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1Image" title="nibabel.nifti1.Nifti1Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Image</span></code></a><a class="headerlink" href="#nifti1image" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1Image">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1Image</code><span class="sig-paren">(</span><em class="sig-param">dataobj</em>, <em class="sig-param">affine</em>, <em class="sig-param">header=None</em>, <em class="sig-param">extra=None</em>, <em class="sig-param">file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.nifti1.Nifti1Pair" title="nibabel.nifti1.Nifti1Pair"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.nifti1.Nifti1Pair</span></code></a>, <a class="reference internal" href="nibabel.filebasedimages.html#nibabel.filebasedimages.SerializableImage" title="nibabel.filebasedimages.SerializableImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.filebasedimages.SerializableImage</span></code></a></p>
<p>Class for single file NIfTI1 format image</p>
<p>Initialize image</p>
<p>The image is a combination of (array-like, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute
or property</p>
</dd>
<dt><strong>affine</strong><span class="classifier">None or (4,4) array-like</span></dt><dd><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal notranslate"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both a <cite>header</cite> and an <cite>affine</cite> are specified, and the <cite>affine</cite> does
not match the affine that is in the <cite>header</cite>, the <cite>affine</cite> will be used,
but the <code class="docutils literal notranslate"><span class="pre">sform_code</span></code> and <code class="docutils literal notranslate"><span class="pre">qform_code</span></code> fields in the header will be
re-initialised to their default values. This is performed on the basis
that, if you are changing the affine, you are likely to be changing the
space to which the affine is pointing.  The <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_sform()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">set_qform()</span></code> methods can be used to update the codes after an image
has been created - see those methods, and the <a class="reference internal" href="../nifti_images.html#default-sform-qform-codes"><span class="std std-ref">manual</span></a> for more details.</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1Image.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dataobj</em>, <em class="sig-param">affine</em>, <em class="sig-param">header=None</em>, <em class="sig-param">extra=None</em>, <em class="sig-param">file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Image.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize image</p>
<p>The image is a combination of (array-like, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute
or property</p>
</dd>
<dt><strong>affine</strong><span class="classifier">None or (4,4) array-like</span></dt><dd><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal notranslate"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both a <cite>header</cite> and an <cite>affine</cite> are specified, and the <cite>affine</cite> does
not match the affine that is in the <cite>header</cite>, the <cite>affine</cite> will be used,
but the <code class="docutils literal notranslate"><span class="pre">sform_code</span></code> and <code class="docutils literal notranslate"><span class="pre">qform_code</span></code> fields in the header will be
re-initialised to their default values. This is performed on the basis
that, if you are changing the affine, you are likely to be changing the
space to which the affine is pointing.  The <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_sform()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">set_qform()</span></code> methods can be used to update the codes after an image
has been created - see those methods, and the <a class="reference internal" href="../nifti_images.html#default-sform-qform-codes"><span class="std std-ref">manual</span></a> for more details.</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Image.files_types">
<code class="sig-name descname">files_types</code><em class="property"> = (('image', '.nii'),)</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Image.files_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Image.header_class">
<code class="sig-name descname">header_class</code><a class="headerlink" href="#nibabel.nifti1.Nifti1Image.header_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Header</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Image.update_header">
<code class="sig-name descname">update_header</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Image.update_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonize header with image data and affine</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Image.valid_exts">
<code class="sig-name descname">valid_exts</code><em class="property"> = ('.nii',)</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Image.valid_exts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1pair">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair" title="nibabel.nifti1.Nifti1Pair"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1Pair</span></code></a><a class="headerlink" href="#nifti1pair" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1Pair">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1Pair</code><span class="sig-paren">(</span><em class="sig-param">dataobj</em>, <em class="sig-param">affine</em>, <em class="sig-param">header=None</em>, <em class="sig-param">extra=None</em>, <em class="sig-param">file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.analyze.html#nibabel.analyze.AnalyzeImage" title="nibabel.analyze.AnalyzeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.analyze.AnalyzeImage</span></code></a></p>
<p>Class for NIfTI1 format image, header pair</p>
<p>Initialize image</p>
<p>The image is a combination of (array-like, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute
or property</p>
</dd>
<dt><strong>affine</strong><span class="classifier">None or (4,4) array-like</span></dt><dd><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal notranslate"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both a <cite>header</cite> and an <cite>affine</cite> are specified, and the <cite>affine</cite> does
not match the affine that is in the <cite>header</cite>, the <cite>affine</cite> will be used,
but the <code class="docutils literal notranslate"><span class="pre">sform_code</span></code> and <code class="docutils literal notranslate"><span class="pre">qform_code</span></code> fields in the header will be
re-initialised to their default values. This is performed on the basis
that, if you are changing the affine, you are likely to be changing the
space to which the affine is pointing.  The <a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_sform" title="nibabel.nifti1.Nifti1Pair.set_sform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_sform()</span></code></a> and
<a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_qform" title="nibabel.nifti1.Nifti1Pair.set_qform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_qform()</span></code></a> methods can be used to update the codes after an image
has been created - see those methods, and the <a class="reference internal" href="../nifti_images.html#default-sform-qform-codes"><span class="std std-ref">manual</span></a> for more details.</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dataobj</em>, <em class="sig-param">affine</em>, <em class="sig-param">header=None</em>, <em class="sig-param">extra=None</em>, <em class="sig-param">file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize image</p>
<p>The image is a combination of (array-like, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects
contained in the <cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute
or property</p>
</dd>
<dt><strong>affine</strong><span class="classifier">None or (4,4) array-like</span></dt><dd><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal notranslate"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both a <cite>header</cite> and an <cite>affine</cite> are specified, and the <cite>affine</cite> does
not match the affine that is in the <cite>header</cite>, the <cite>affine</cite> will be used,
but the <code class="docutils literal notranslate"><span class="pre">sform_code</span></code> and <code class="docutils literal notranslate"><span class="pre">qform_code</span></code> fields in the header will be
re-initialised to their default values. This is performed on the basis
that, if you are changing the affine, you are likely to be changing the
space to which the affine is pointing.  The <a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_sform" title="nibabel.nifti1.Nifti1Pair.set_sform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_sform()</span></code></a> and
<a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_qform" title="nibabel.nifti1.Nifti1Pair.set_qform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_qform()</span></code></a> methods can be used to update the codes after an image
has been created - see those methods, and the <a class="reference internal" href="../nifti_images.html#default-sform-qform-codes"><span class="std std-ref">manual</span></a> for more details.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.as_reoriented">
<code class="sig-name descname">as_reoriented</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ornt</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.as_reoriented" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an orientation change and return a new image</p>
<p>If ornt is identity transform, return the original image, unchanged</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ornt</strong><span class="classifier">(n,2) orientation array</span></dt><dd><p>orientation transform. <code class="docutils literal notranslate"><span class="pre">ornt[N,1]`</span> <span class="pre">is</span> <span class="pre">flip</span> <span class="pre">of</span> <span class="pre">axis</span> <span class="pre">N</span> <span class="pre">of</span> <span class="pre">the</span>
<span class="pre">array</span> <span class="pre">implied</span> <span class="pre">by</span> <span class="pre">`shape`,</span> <span class="pre">where</span> <span class="pre">1</span> <span class="pre">means</span> <span class="pre">no</span> <span class="pre">flip</span> <span class="pre">and</span> <span class="pre">-1</span> <span class="pre">means</span>
<span class="pre">flip.</span>&#160; <span class="pre">For</span> <span class="pre">example,</span> <span class="pre">if</span> <span class="pre">``N==0</span></code> and <code class="docutils literal notranslate"><span class="pre">ornt[0,1]</span> <span class="pre">==</span> <span class="pre">-1</span></code>, and
there’s an array <code class="docutils literal notranslate"><span class="pre">arr</span></code> of shape <cite>shape</cite>, the flip would
correspond to the effect of <code class="docutils literal notranslate"><span class="pre">np.flipud(arr)</span></code>.  <code class="docutils literal notranslate"><span class="pre">ornt[:,0]</span></code> is
the transpose that needs to be done to the implied array, as in
<code class="docutils literal notranslate"><span class="pre">arr.transpose(ornt[:,0])</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.get_qform">
<code class="sig-name descname">get_qform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">coded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.get_qform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 affine matrix from qform parameters in header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coded</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return {affine or None}, and qform code.  If False, just
return affine.  {affine or None} means, return None if qform code
== 0, and affine otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or (4,4) ndarray</span></dt><dd><p>If <cite>coded</cite> is False, always return affine reconstructed from qform
quaternion.  If <cite>coded</cite> is True, return None if qform code is 0,
else return the affine.</p>
</dd>
<dt><strong>code</strong><span class="classifier">int</span></dt><dd><p>Qform code. Only returned if <cite>coded</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_qform" title="nibabel.nifti1.Nifti1Pair.set_qform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_qform</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.get_sform" title="nibabel.nifti1.Nifti1Pair.get_sform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sform</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.get_sform">
<code class="sig-name descname">get_sform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">coded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.get_sform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 affine matrix from sform parameters in header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coded</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return {affine or None}, and sform code.  If False, just
return affine.  {affine or None} means, return None if sform code
== 0, and affine otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or (4,4) ndarray</span></dt><dd><p>If <cite>coded</cite> is False, always return affine from sform fields. If
<cite>coded</cite> is True, return None if sform code is 0, else return the
affine.</p>
</dd>
<dt><strong>code</strong><span class="classifier">int</span></dt><dd><p>Sform code. Only returned if <cite>coded</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_sform" title="nibabel.nifti1.Nifti1Pair.set_sform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sform</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.get_qform" title="nibabel.nifti1.Nifti1Pair.get_qform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_qform</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Pair.header_class">
<code class="sig-name descname">header_class</code><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.header_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.nifti1.Nifti1PairHeader" title="nibabel.nifti1.Nifti1PairHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1PairHeader</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1Pair.rw">
<code class="sig-name descname">rw</code><em class="property"> = True</em><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.rw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.set_qform">
<code class="sig-name descname">set_qform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">code=None</em>, <em class="sig-param">strip_shears=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.set_qform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set qform header values from 4x4 affine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or 4x4 array</span></dt><dd><p>affine transform to write into sform. If None, only set code.</p>
</dd>
<dt><strong>code</strong><span class="classifier">None, string or integer</span></dt><dd><p>String or integer giving meaning of transform in <em>affine</em>.
The default is None.  If code is None, then:</p>
<ul class="simple">
<li><p>If affine is None, <cite>code</cite>-&gt; 0</p></li>
<li><p>If affine not None and existing qform code in header == 0,
<cite>code</cite>-&gt; 2 (aligned)</p></li>
<li><p>If affine not None and existing qform code in header != 0,
<cite>code</cite>-&gt; existing qform code in header</p></li>
</ul>
</dd>
<dt><strong>strip_shears</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to strip shears in <cite>affine</cite>.  If True, shears will be
silently stripped. If False, the presence of shears will raise a
<code class="docutils literal notranslate"><span class="pre">HeaderDataError</span></code></p>
</dd>
<dt><strong>update_affine</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to update the image affine from the header best affine
after setting the qform. Must be keyword argument (because of
different position in <cite>set_qform</cite>). Default is True</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.get_qform" title="nibabel.nifti1.Nifti1Pair.get_qform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_qform</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_sform" title="nibabel.nifti1.Nifti1Pair.set_sform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sform</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">Nifti1Pair</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">get_qform</span><span class="p">()</span>
<span class="go">array([[2., 0., 0., 0.],</span>
<span class="go">       [0., 3., 0., 0.],</span>
<span class="go">       [0., 0., 4., 0.],</span>
<span class="go">       [0., 0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">get_qform</span><span class="p">(</span><span class="n">coded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">set_qform</span><span class="p">(</span><span class="n">aff2</span><span class="p">,</span> <span class="s1">&#39;talairach&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qaff</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_qform</span><span class="p">(</span><span class="n">coded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">qaff</span> <span class="o">==</span> <span class="n">aff2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.set_sform">
<code class="sig-name descname">set_sform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">affine</em>, <em class="sig-param">code=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.set_sform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sform transform from 4x4 affine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">None or 4x4 array</span></dt><dd><p>affine transform to write into sform.  If None, only set <cite>code</cite></p>
</dd>
<dt><strong>code</strong><span class="classifier">None, string or integer</span></dt><dd><p>String or integer giving meaning of transform in <em>affine</em>.
The default is None.  If code is None, then:</p>
<ul class="simple">
<li><p>If affine is None, <cite>code</cite>-&gt; 0</p></li>
<li><p>If affine not None and existing sform code in header == 0,
<cite>code</cite>-&gt; 2 (aligned)</p></li>
<li><p>If affine not None and existing sform code in header != 0,
<cite>code</cite>-&gt; existing sform code in header</p></li>
</ul>
</dd>
<dt><strong>update_affine</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to update the image affine from the header best affine
after setting the qform.  Must be keyword argument (because of
different position in <cite>set_qform</cite>). Default is True</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.get_sform" title="nibabel.nifti1.Nifti1Pair.get_sform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sform</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nibabel.nifti1.Nifti1Pair.set_qform" title="nibabel.nifti1.Nifti1Pair.set_qform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_qform</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">Nifti1Pair</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">get_sform</span><span class="p">()</span>
<span class="go">array([[2., 0., 0., 0.],</span>
<span class="go">       [0., 3., 0., 0.],</span>
<span class="go">       [0., 0., 4., 0.],</span>
<span class="go">       [0., 0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saff</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_sform</span><span class="p">(</span><span class="n">coded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saff</span>
<span class="go">array([[2., 0., 0., 0.],</span>
<span class="go">       [0., 3., 0., 0.],</span>
<span class="go">       [0., 0., 4., 0.],</span>
<span class="go">       [0., 0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aff2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">set_sform</span><span class="p">(</span><span class="n">aff2</span><span class="p">,</span> <span class="s1">&#39;talairach&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saff</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_sform</span><span class="p">(</span><span class="n">coded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">saff</span> <span class="o">==</span> <span class="n">aff2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.nifti1.Nifti1Pair.update_header">
<code class="sig-name descname">update_header</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1Pair.update_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonize header with image data and affine</p>
<p>See AnalyzeImage.update_header for more examples</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">Nifti1Image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_qform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hdr</span><span class="o">.</span><span class="n">get_sform</span><span class="p">()</span> <span class="o">==</span> <span class="n">affine</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nifti1pairheader">
<h2><a class="reference internal" href="#nibabel.nifti1.Nifti1PairHeader" title="nibabel.nifti1.Nifti1PairHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nifti1PairHeader</span></code></a><a class="headerlink" href="#nifti1pairheader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.nifti1.Nifti1PairHeader">
<em class="property">class </em><code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">Nifti1PairHeader</code><span class="sig-paren">(</span><em class="sig-param">binaryblock=None</em>, <em class="sig-param">endianness=None</em>, <em class="sig-param">check=True</em>, <em class="sig-param">extensions=()</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1PairHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nibabel.nifti1.Nifti1Header" title="nibabel.nifti1.Nifti1Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.nifti1.Nifti1Header</span></code></a></p>
<p>Class for NIfTI1 pair header</p>
<p>Initialize header from binary data block and extensions</p>
<dl class="method">
<dt id="nibabel.nifti1.Nifti1PairHeader.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">binaryblock=None</em>, <em class="sig-param">endianness=None</em>, <em class="sig-param">check=True</em>, <em class="sig-param">extensions=()</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.Nifti1PairHeader.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize header from binary data block and extensions</p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.nifti1.Nifti1PairHeader.is_single">
<code class="sig-name descname">is_single</code><em class="property"> = False</em><a class="headerlink" href="#nibabel.nifti1.Nifti1PairHeader.is_single" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="load">
<h2>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.nifti1.load">
<code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load NIfTI1 single or pair from <cite>filename</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>filename of image to be loaded</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img</strong><span class="classifier">Nifti1Image or Nifti1Pair</span></dt><dd><p>NIfTI1 single or pair image instance</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ImageFileError</dt><dd><p>if <cite>filename</cite> doesn’t look like NIfTI1;</p>
</dd>
<dt>IOError</dt><dd><p>if <cite>filename</cite> does not exist.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="save">
<h2>save<a class="headerlink" href="#save" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.nifti1.save">
<code class="sig-prename descclassname">nibabel.nifti1.</code><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">img</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.nifti1.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save NIfTI1 single or pair to <cite>filename</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>filename to which to save image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2020, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>